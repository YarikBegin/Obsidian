[[JavaScript]]

Первый тип атак, с которым мы разберёмся — межсайтовый скриптинг (cross-site scripting). Вы уже встречались с этими атаками, когда знакомились со свойством `innerHTML`. Тогда мы рассказывали историю о Сэмми, который воспользовался недосмотром разработчиков MySpace, собрал за несколько часов миллион друзей и «положил» тем самым сервер соцсети.

И хотя истории Сэмми уже больше 14 лет, XSS по-прежнему входит в десятку самых опасных уязвимостей веб-приложений.

Суть XSS-атак в том, чтобы внедрить вредоносный код в страницу, которую сервер отдаёт пользователю. Сэмми отредактировал свою страницу на MySpace, внедрив в неё вредоносный код. MySpace сохранил эту страницу у себя на сервере и выдавал другим пользователям. Вредоносный код запускался у них на компьютерах и творил бесчинства.

## Если отказаться от innerHTML, всё будет хорошо?

К сожалению, нет. Есть множество способов осуществить межсайтовый скриптинг.

Виктор оставляет на сайте отзыв и передаёт внутри запроса имя:

Скопировать кодJAVASCRIPT

```
http://example.com/?name=Виктор 
```

Сервер обрабатывает запрос, выкладывает отзыв и подписывает его переданным именем:

Скопировать кодJAVASCRIPT

```
const express = require('express');
const app = express();

// код для передачи отзыва
app.get('/', (req, res) => {
  res.send(`Автор отзыва: ${req.query.name}`);
});

app.listen(3000); 
```

Эту логику могут использовать хакеры. В ссылку можно вставить вредоносный код, а потом как-то вынудить другого пользователя эту ссылку открыть: сообщением о выигрыше в лотерею, скидкой 99% на гоночный автомобиль или предложением изменить размеры какого-нибудь органа:

Скопировать кодJSX

```
// Такая ссылка может прийти в письме «Перейдите по ссылке, чтобы получить свой выигрыш!»
http://example.com/?name=Виктор+<script>alert('Hacked!');</script> 
```

Мы в примере просто показываем окно с сообщением "Hacked", но хакеры предпочитают код повреднее.

## Кто поможет, кто защитит?

В борьбе с киберпреступностью вы не одиноки. Наш пример атаки не сработает в браузерах на движке chromium: Яндекс-браузере, Гугл-хроме. В самом движке предусмотрена защита, так что попытка открыть такую ссылку приведёт к ошибке: _"The XSS Auditor refused to execute a script in '[http://example.com/?name=Viktor+](http://example.com/?name=Viktor+)<script>alert('Hacked!');</script>' because its source code was found within the request. The auditor was enabled as the server did not send an 'X-XSS-Protection' header."_ Что означает _«XSS-аудитор отклонил выполнение скрипта на странице '[http://example.com/?name=Viktor+](http://example.com/?name=Viktor+)<script>alert('Hacked!');</script>', поскольку в запросе был найден исполняемый код. Аудитор включён, поскольку сервер не отправил заголовок „X-XSS-Protection“»_.

Но в Internet Explorer никакой ошибки не выдаст, а послушно выполнит вредоносный код. Да и на хромиумы полагаться не стоит, от такого кода они не защитят:

Скопировать кодJAVASCRIPT

```
http://example.com/?name=Виктор+<b><a href="http://сайтхакера">YOU WON $100000</a> 
```

Хакер может пойти ещё дальше: сократить ссылку специальным сервисом, исполнить скрипт на компьютере пользователя и перенаправить его на исходный сайт. Так пользователь и не заметит, что произошло что-то неладное.

## Что же делать?

### Ограничивать пользовательский ввод

Для этого применяют принцип «Что не разрешено — запрещено». Он заключается в том, чтобы заранее установить разрешённые для ввода символы в каждое поле: поле «автор» может содержать только кириллические буквы и пробел, номер телефона — цифры, знак «плюс» и скобки, email — латинские буквы, цифры, нижние подчёркивания, дефисы, точки и символ «собака». Если пользователь вводит неразрешённые символы, сайт либо их отбрасывает, либо сообщает об ошибке.

### Экранировать символы

Иногда нам нужно отправить символы, которые используются злоумышленниками. Например, `<` и `>` могут быть знаками «меньше» и «больше», а не границами тега. В этом случае мы не можем запретить их для ввода.

В этом случае символы следует экранировать, тогда браузер не станет воспринимать их как код. Поэтому экранирование защищает от внедрения скриптов.

**Экранирование символов в HTML**

Допустим, мы сделали сервис для решения математических неравенств. Пользователь отправляет пример:

Скопировать кодJAVASCRIPT

```
"x * 2 < 4"; 
```

Сервер решает неравенство и возвращает ответ:

Скопировать кодJAVASCRIPT

```
"Неравенство x * 2 < 4 верно при x < 2"; 
```

Мы не можем запретить символ `<`, но можем его экранировать. Для этого его следует заменить на символ с кодовым обозначением — мнемоникой. Для знака «меньше» это `&lt;`. Получится такая строка:

Скопировать кодJAVASCRIPT

```
"Неравенство x * 2 &lt; 4 верно при x &lt; 2"; 
```

Если злоумышленник отправит на сервер скрипт, мы не станем беспокоиться, что тот будет исполнен на компьютере пользователя. Ведь все символы экранированы и браузер этот скрипт не запустит:

Скопировать кодJAVASCRIPT

```
// Злоумышленник отправил:
Виктор+<script>alert('Hacked!');</script>

// Пользователь получил:
Виктор+&lt;script&gt;alert('Hacked!');&lt;/script&gt; 
```

### Экранирование на практике

В node.js уже есть модуль, подставляющий мнемоники: `escape-html`. Его можно импортировать в проект и использовать в коде:

Скопировать кодJAVASCRIPT

```
const escape = require('escape-html'); 
```

Переменная `escape` содержит в себе функцию, которая принимает на вход строку со спецсимволами и заменяет их на мнемоники:

Скопировать кодJAVASCRIPT

```
escape('<script>alert("hacked")</script>');

// '&lt;script&gt;alert(&quot;hacked&quot;)&lt;/script&gt; 
```

## Content Security Policy

Основная защита от XSS — правильно написанный код веб-приложения: с ограниченным вводом и экранированием символов. Но бывает всякое, и злоумышленник всё равно может найти способ внедрить скрипт в браузер пользователя. На этот случай есть вторая линия защиты — инструкция Content Security Policy.

Эта инструкция позволяет ограничить источники, откуда сайт может загружать скрипты, изображения, файлы стилей и медиафайлы.

Есть два варианта установить инструкцию:

1. В метатеге. Можно добавить в раздел `head` тег `meta` и описать ограничения там:
    
    Скопировать кодJAVASCRIPT
    
    ```
     <meta http-equiv="Content-Security-Policy" content="ИНСТРУКЦИИ">
      
    ```
    
2. В HTTP-заголовке:
    
    Скопировать кодJAVASCRIPT
    
    ```
     Content-Security-Policy: /* ИНСТРУКЦИИ */
      
    ```
    

### Как оформить инструкции

Есть 5 видов инструкций:

- `default-src` — обязательная инструкция, задаёт источник всех видов ресурсов по умолчанию;
- `script-src` — источник скриптов;
- `img-src` — изображений;
- `media-src` — аудио- и видео-файлов;
- `style-src` — файлов стилей.

После имени инструкции указывают сами источники через пробел. Чтобы указать домен сайта как источник, устанавливают ключевое слово `'self'`.

Скопировать кодJAVASCRIPT

```
"script-src 'self' *.site.com"; // скрипты можно загружать с самого сайта, либо с поддоменов site.com, например, с https://example.site.com 
```

В конце каждой инструкции должна стоять точка с запятой:

Скопировать кодJAVASCRIPT

```
Content-Security-Policy: default-src 'self'; img-src *; media-src media1.com media2.com; script-src userscripts.example.com 
```

## Контроль версии браузера

Более новые браузеры обычно лучше защищены. Поэтому во имя безопасности можно запретить вход на сайт пользователям со старых браузеров.

Браузер отправляет свою версию в любом запросе внутри заголовка User-Agent. Этот заголовок имеет формат:

Скопировать кодJAVASCRIPT

```
User-Agent: <product> / <product-version> <comment> 
```

Например:

Скопировать кодJAVASCRIPT

```
user-agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/77.0.3865.90 Safari/537.36 
```

Не пускать пользователя со старого браузера хорошо для безопасности. Но для пользователя это неудобно. Это противоречие обуславливает два подхода:

- поддерживать максимально возможное число браузеров, вплоть до старых версий Internet Explorer;
- не пускать пользователей старых браузеров.

Второй подход используют Вконтакте:

![image](https://pictures.s3.yandex.net/resources/Untitled_1599389501.png)

Какой подход выбрать — решать команде сервиса. Всегда взвешивайте, что важнее: безопасность или дружелюбие к пользователю.

## Итого

При любой XSS-атаке хакеры пользуются тем, что данные от пользователей попадают на сервер, а затем — обратно в браузер без каких-либо проверок. Поэтому чтобы защититься от XSS-атак:

- По возможности не передавайте параметры в URL. Используйте POST для отправки данных форм.
- Экранируйте спецсимволы при получении и отображении данных.
- Устанавливайте Content Security Policy HTTP-заголовки или Meta-тэги.
- Контролируйте пользовательский ввод согласно принципу «что не разрешено — запрещено».
- Напоминайте посетителям обновить браузер.