[[Объектно-ориентированное программирование. Введение]]

В прошлом уроке мы говорили о 2-х случаях привязки `this`:

1.  По умолчанию.
2.  Явная привязка методом `bind`.

У каждого способа есть свой приоритет. Начнём с самого низкого — привязки по умолчанию. В этом случае вы просто вызываете функцию по её имени, то есть пишете имя функции и круглые скобки. Тогда `this` принимает значение `window`:

Скопировать кодJAVASCRIPT

```
function globalFunction() {
  console.log(this);
}

globalFunction(); // Window — this ссылается на глобальный объект window 
```

Функция `globalFunction` вызывается просто по имени. Поэтому `this` ссылается на объект `window`.

Ключевое слово `this` может принимать и другое значение. Вы изучите это в следующей теме о `this`.

## Потеря контекста

Привязку по умолчанию редко используют намеренно — обычно это следствие какой-то ошибки или потери контекста. Например, потерять контекст можно, передав функцию как колбэк:

Скопировать кодJAVASCRIPT

```
class SendButton {
    constructor() {
        this.buttonName = 'Send Button';
    }

    click() {
        console.log('I am ' + this.buttonName);
    }

    setEventListeners() {
        // Передадим слушателю события метод SendButton.click как колбэк:
        document.querySelector('.btn').addEventListener('click', this.click); // При клике мы надеемся увидеть сообщение "I am Send Button"
    }
}

const button = new SendButton();
button.setEventListeners(); 
```

Наша задача была — выводить имя кнопки при каждом нажатии на неё. Но это не сработало, потому что `this` определяется в момент вызова функции, то есть в момент клика по элементу. Важно, что функция `click` не вызывается как метод класса — она передаётся методу `addEventListener` и вызывается из него. Механизм слушателя события такой, что `this` при этом ссылается на DOM-элемент, на котором событие сработало. У DOM-узла нет свойства `buttonName`, поэтому в консоли оказывается сообщение `I am undefined`.

Потери контекста можно избежать, если явным образом указать функции значение `this`. О том, как это сделать, расскажем в следующем уроке.

# Заключение

Это была капля в море `this`. Но вы успешно с ней справились. Повторим, что вы уже знаете.

Чтобы правильно определить значение `this`, нужно изучить точку вызова функции. Привязка `this` подчиняется пяти правилам. В этом разделе вы узнали про два из них:

1.  Если функция вызвана после привязки методом `bind`, в `this` оказывается переданный в метод объект.
2.  По умолчанию — глобальный объект `window`.

Умение определять привязку по умолчанию поможет быстрее находить участки в коде, где внутри функции потерялся контекст.

А явную привязку методом `bind` удобно использовать, чтобы избежать потери контекста в функциях.

Ничего страшного, если понимание того, где переопределяется контекст, не пришло сразу. Скорее всего, на земле нет ни одного JavaScript-разработчика, не терявшего контекст ни разу. Осознанно с ним работать сложно даже опытным разработчикам.

Впереди ещё много секретов, которые хранит в себе `this`. Но о них вы узнаете в следующих спринтах.