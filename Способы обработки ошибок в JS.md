[[JavaScript]]

Обработка ошибок в JS — непростая задача, поскольку в языке нет универсального способа для её решения. Обработка реализовывается по-разному в зависимости от того, синхронная функция или асинхронная, а также от самого подхода к реализации асинхронности. В этом уроке мы рассмотрим каждый из указанных случаев.

## Обработка ошибок в синхронном коде

Для обработки ошибок в синхронном коде применяют конструкцию `try-catch`. Она вам уже знакома, поэтому коротко напомним, как она работает: код, в котором необходимо обработать ошибки, помещается в блок `try`, а функция-обработчик описывается в `catch`.

К сожалению, у конструкции есть существенный недостаток: она не работает с асинхронным кодом и пропускает ошибки, которые возникают в промисах и колбэках. В этом легко убедиться, если добавить в блок `try` промис, возвращающий ошибку при помощи конструкции `Promise.reject`:

Скопировать кодJAVASCRIPT

```
(function testAsyncError() {
    try {
        console.log("Запускаем выполнение кода")
        return Promise.reject(new Error("Ошибка. Что-то пошло не так..."))
    } catch (err) {
        console.log(`Произошла ошибка ${err.name} c текстом ${err.message}, но мы её обработали`)
    }
    console.log("Выполнение функции завершено успешно")
})() 
```

Когда запустим этот код, мы обнаружим, что ошибка не перехвачена, а наш код упал.

![image](https://pictures.s3.yandex.net/resources/01_1630395858.png)

_Ошибка не была перехвачена, и код упал._

К счастью, существует способ, который позволяет исправить это поведение, — использование синтаксиса async\await.

### Обработка ошибок в асинхронном коде. Async/await

Задача синтаксиса async/await — дать разработчику возможность писать асинхронный код в синхронном стиле. Проще говоря, он позволяет указать движку JS места, в которых необходимо «дождаться» результата выполнения промиса перед тем, как идти дальше по коду.

Перепишем код из примера выше с использованием async/await.

Для большей наглядности вынесем код, который возвращает промис с ошибкой, в отдельную функцию `returnPromiseError`. Чтобы внутри функции заработала конструкция `await`, нам необходимо пометить её ключевым словом `async`. Добавим его перед определением функции `testAsyncAwaitError`.

Чтобы JS дождался завершения работы `returnPromiseError` и ошибка в `returnPromiseError` была перехвачена, перед вызовом функции добавим ключевое слово `await`.

В результате получим такой код:

Скопировать кодJAVASCRIPT

```
// Вынесли код возврата промиса с ошибкой во внешнюю функцию
function returnPromiseError() { 
   return Promise.reject(new Error("Ошибка. Что-то пошло не так...")) 
}

(async function testAsyncAwaitError() {
try {
    console.log("Запускаем выполнение кода")
    await returnPromiseError(); // дожидаемся завершения работы returnPromiseError
} catch(err) {
    console.log(`При выполнении кода произошла ошибка ${err.name} c текстом ${err.message}, но мы её обработали`)
}
console.log("Выполнение функции завершено успешно")
})() 
```

Запустим его в консоли браузера.

Теперь выполнение функции завершается успешно, о чём нам сообщает заветная строчка «Выполнение функции завершено успешно», которая появилась в консоли браузера.

![image](https://pictures.s3.yandex.net/resources/02_1630395906.png)

Кроме того, сама ошибка попадает в обработчик в catch-блоке и обрабатывается соответствующим образом (в нашем случае — выводится в консоль).

А это значит, что задача успешно выполнена! Однако это не единственный способ обработки ошибок, которые возникают в промисах. Переходим к следующему.

### Обработка ошибок в промисах. Обработчик .catch

Другой, уже известный вам подход, — использование Promise-обработчика `.catch`. Он работает так: если при выполнении кода в промисе происходит ошибка, то она попадает в ближайший .catch-блок, описанный за ним. Звучит сложновато, но на практике всё достаточно просто. Разберёмся на примере.

У нас есть такой фрагмент кода:

Скопировать кодJAVASCRIPT

```
// Вынесли код возврата промиса с ошибкой во внешнюю функцию
function returnPromiseError() { 
   return Promise.reject(new Error("Ошибка. Что-то пошло не так...")) 
}

(function testPromiseRejectHandler() {
    returnPromiseError()
})()
 
```

Выполним код. В процессе вызова `returnPromiseError` в функции `testPromiseRejectHandler` происходит ошибка, и код падает. Обработаем её, добавив в конце вызова обработчик `.catch`:

Скопировать кодJAVASCRIPT

```
function returnPromiseError() { return Promise.reject(new Error("Ошибка. Что-то пошло не так...")) }
(function testPromiseRejectHandler() {
    returnPromiseError()
    .catch((err)=>{
        console.log(`При выполнении кода произошла ошибка ${err.name} c текстом ${err.message}, но мы её обработали`)
    })
})()
 
```

Ошибка, которая возникла при выполнении кода, была успешно перехвачена и обработана. Обратите внимание, что при обработке последовательности вызова промисов, в цепочке может быть несколько .catch-обработчиков. В таком случае ошибка попадёт в ближайший к месту возникновения ошибки.

### Ошибки в колбэках

Когда асинхронные функции в JS реализуются при помощи колбэков, обработка ошибок в них происходит немного иначе.

Результат выполнения функции, согласно принятым соглашениям в мире JS, возвращается в колбэк в виде двух аргументов:

- в первый попадает объект ошибки (если она возникает);
- во второй — результат операции.

Обработка ошибок в колбэках сводится к обработке значения первого аргумента.

Рассмотрим обработку ошибок в колбэках на конкретном примере. Напишем функцию, которая записывает некоторый текст в указанный файл на диске. Для этого воспользуемся уже знакомым вам методом `writeFile` модуля `fs`:

Скопировать кодJAVASCRIPT

```
const fs = require('fs');
// функция, записывающая строчку в указанный файл
function writeTextToFile(filename, text) {
    fs.writeFile(filename, text, function (err, res) {
        console.log(`fs.writeFile завершилась с таким результатом: ${res}`)
    })
}
// вызовем её, передав некорректное имя файла - ''
writeTextToFile('', 'sometext');
 
```

Для запуска этого и последующих примеров в уроке вам потребуется интерпретатор Node.js. Чтобы выполнить код примера, сохраните его в удобном для вас месте на диске компьютера и запустите при помощи команды `node <имя_файла>`.

Вопреки нашим ожиданиям, при попытке запуска примера ничего не ломается. Всё выглядит, будто код отработал корректно, хотя это не совсем правда. Так произошло потому, что в коде фактически отсутствует обработка ошибок. Значение первого аргумента колбэка — `err`, в который передаётся ошибка, никак не проверяется, а сама ошибка оказывается не обработанной. Коварство колбэков для разработчика состоит в том, что пропущенные ошибки в них не приводят к падению приложения и часто оказываются незамеченными.

Исправим код примера, добавив соответствующую проверку:

Скопировать кодJAVASCRIPT

```
const fs = require('fs');
function writeTextToFile(filename, text) {
    fs.writeFile(filename, text, function(err, res){
        // проверяем, что объект ошибки не пустой
        if (err) {
            console.error(`Произошла ошибка при записи файла: ${err.message}`);
            // завершаем выполнением функции при возникновении ошибки
            return;
        }
        console.log(`fs.writeFile завершилась с таким резульатом: ${res}`)
    })
}
writeTextToFile('', 'sometext');
 
```

Теперь ошибка обрабатывается корректно, а в консоль падает соответствующее сообщение: `Произошла ошибка при записи файла: ENOENT: no such file or directory, open ''`.

К сожалению, иногда происходит ситуация, когда обработка ошибок оказывается пропущена и код падает. В следующем уроке мы поговорим о глобальных обработчиках ошибок, которые позволят нам это предотвратить, а также опишем собственный класс ошибки. А пока пришло время попрактиковаться: в заданиях вам предстоит добавить обработку ошибок в разные типы функций.