[[JavaScript]]

В предыдущем уроке вы настроили роутинг на экспрессе. Сейчас для каждого запроса есть свой обработчик: когда клиент запрашивает страницу, срабатывает соответствующий обработчик.

Такая логика подходит не всегда. Невозможно написать по обработчику для каждой страницы пользователя в соцсети или к каждому плейлисту в музыкальном сервисе. Вместо этого используют динамические роуты.

## Что такое динамические роуты?

Раньше вы писали статические роуты, они обрабатывали запросы на конкретные адреса: /, /animals, /search.

Динамический роут — это обработчики шаблона адреса. То есть сразу всех адресов, подходящих под определённое правило.

Чтобы создать динамический роут, в URL укажите двоеточие и имя свойства, которое может меняться:

Скопировать кодJAVASCRIPT

```
app.get('/users/:id', (req, res) => { 
    // Этот код обработает все запросы, чей путь начинается с /users/111111
}); 
```

Обратите внимание: значение переменной в адресе не может быть пустым. Вот такой запрос не будет обработан:

Скопировать кодBASH

```
http://localhost:3000/users 
```

## Параметры роута

Обработать запрос мало — нужно получить его параметры, чтобы отдавать пользователю нужные данные. В экспрессе это просто: все параметры запроса становятся свойствами JSON-объекта `req.params`:

Скопировать кодJAVASCRIPT

```
app.get('/users/:id', (req, res) => {
  res.send(req.params);

    /* Если отправить запрос на адрес "http://localhost:3000/users/123",
     внутри объекта req.params окажется JSON-объект:
     { "id": "123" } */
}); 
```

Формат JSON оказывается тут как никогда кстати. Особенно при обработке адресов со множественной вложенностью:

Скопировать кодJAVASCRIPT

```
app.get('/users/:id/albums/:album/:photo', (req, res) => {
  const { id, album, photo } = req.params;

    /* При обращению к адресу "http://localhost:3000/users/123/albums/333/2"
     параметры запроса будут записаны в таком виде:
     {"id":"123","album":"333","photo":"2"}

     Мы записали их в переменные id, album и photo */

  res.send(`Мы на странице пользователя с id ${id}, смотрим альбом №${album} и фотографию №${photo}`);
}); 
```

## Как организовать роутинг

Мы уже не раз говорили о преимуществах модульного кода. Логику роутинга тоже следует разнести по разным файлам. Пусть один отвечает за основную часть сайта, второй — за админку, третий — за мобильное приложение.

Разберёмся, как разбить этот код на модули:

Скопировать кодJAVASCRIPT

```
// Здесь функциональность точки входа
const express = require('express');

const { PORT = 3000 } = process.env;
const app = express();

// Здесь данные
const users = [
  { name: 'Мария', age: 22 },
  { name: 'Виктор', age: 30 },
  { name: 'Анастасия', age: 48 },
  { name: 'Алексей', age: 51 }
];

// Здесь роутинг
app.get('/users/:id', (req, res) => {
  if (!users[req.params.id]) {
    res.send(`Такого пользователя не существует`);

    // не забудем выйти из функции
    return;
  }

  const { name, age } = users[req.params.id];
  
  res.send(`Пользователь ${name}, ${age} лет`);
});

app.listen(PORT, () => {
    console.log(`App listening on port ${PORT}`);
}); 
```

Первым делом **перенесём данные в отдельный файл** db.js:

Скопировать кодJAVASCRIPT

```
// db.js
module.exports = {
  users: [
    { name: 'Мария', age: 22 },
    { name: 'Виктор', age: 30 },
    { name: 'Анастасия', age: 48 },
    { name: 'Алексей', age: 51 }
  ]
}; 
```

Даже четыре лишние строчки засоряют код. А пользователей на сайте обычно больше четырёх (даже если это сайт администрации малообитаемого острова в Тихом океане). Так что всегда храните данные отдельно.

**Настроим роутер.** Код роутинга тоже перенесём в отдельный файл.

Для этого код придётся дописать. Логика ответа на запросы описана в обработчиках `get`. Мы вызывали `get` как метод самого приложения — переменной `app`. В отдельном модуле с роутингом этой переменной нет. И создать её не получится — может быть только одно приложение. Поэтому в экспрессе есть метод `Router`. Он создаёт объект, на который мы и повесим обработчики:

Скопировать кодJAVASCRIPT

```
// router.js
const router = require('express').Router(); // создали роутер
const { users } = require('./db.js'); // данные нужны для роутинга, поэтому импортируем их

router.get('/users/:id', (req, res) => {
  if (!users[req.params.id]) {
    res.send(`Такого пользователя не существует`);
    return;
  }

  const { name, age } = users[req.params.id];
  
  res.send(`Пользователь ${name}, ${age} лет`);
});

module.exports = router; // экспортировали роутер 
```

К слову, как и в предыдущем уроке, не только GET-метод может быть добавлен к объекту Router:

Скопировать кодJAVASCRIPT

```
router.get('/books', getBooks);
router.post('/books', createBook);
router.put('/books/:id', replaceBook);
router.patch('/books/:id', updateBookInfo); 
router.delete('/books/:id', deleteBook); 
```

**Настроим точку входа.** Для этого импортируем роутер в index.js и запустим его методом `use`. Он принимает на вход два параметра:

- начало URL — роутер будет запускаться только для запросов, начинающихся с этой строки;
- сам роутер:

Скопировать кодJAVASCRIPT

```
// index.js 
const express = require('express');
const router = require('./router.js'); // импортируем роутер

const { PORT = 3000 } = process.env;
const app = express();

app.use('/', router); // запускаем

app.listen(PORT, () => {
    console.log(`App listening on port ${PORT}`);
}); 
```

Первый параметр метода `use` позволяет сделать код модульным. Вы можете написать разные роутеры для разной функциональности:

Скопировать кодJAVASCRIPT

```
const express = require('express');
const router = require('./router.js');
const api = require('./api.js');
const backoffice = require('./backoffice.js');

const { PORT = 3000 } = process.env;
const app = express();

// Для разных запросов разные роутеры.
// Выглядит просто отлично!

app.use('/', router);
app.use('/api', api);
app.use('/admin', backoffice);

app.listen(PORT, () => {
    console.log(`App listening on port ${PORT}`);
}); 
```

На этом всё — роутинг готов. Теперь наше приложение можно гордо называть сервером, ведь оно выполняет его главную функцию: обработку запросов.

В следующем уроке разберём, чем занят сервер между получением запроса и выдачей ответа.