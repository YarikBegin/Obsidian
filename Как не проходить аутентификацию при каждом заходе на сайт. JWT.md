[[JavaScript]]

Вы уже разобрали алгоритм аутентификации. Пользователи могут ввести электронную почту, пароль, и залогиниться.

Скопировать кодJAVASCRIPT

```
// controllers/users.js

module.exports.login = (req, res) => {
  const { email, password } = req.body;

  return User.findUserByCredentials(email, password)
    .then((user) => {
      // аутентификация успешна!
    })
    .catch((err) => {
      res
        .status(401)
        .send({ message: err.message });
    });
}; 
```

Но вводить почту и пароль при каждом переходе на сайт неудобно. Лучше, когда браузер запоминает, что вход на сайт уже выполнен. Так пользователю не нужно вводить данные повторно — как только он откроет страницу, сразу оказывается залогинен.

В теме про «Реакт» вы уже выполняли сохранение токена. Теперь научимся создавать токен на сервере. А в конце темы поговорим про верификацию токена.

## Как создавать токен. Практика

Для создания токенов воспользуемся пакетом `jsonwebtoken`. Его нужно установить и импортировать в проект:

Скопировать кодJAVASCRIPT

```
// controllers/users.js

const jwt = require('jsonwebtoken'); // импортируем модуль jsonwebtoken 
```

Затем вызовем метод `jwt.sign`, чтобы создать токен:

Скопировать кодJAVASCRIPT

```
// controllers/users.js

const jwt = require('jsonwebtoken'); // 

module.exports.login = (req, res) => {
  const { email, password } = req.body;

  return User.findUserByCredentials(email, password)
    .then((user) => {
      // создадим токен
      const token = jwt.sign({ _id: user._id }, 'some-secret-key');

      // вернём токен
      res.send({ token });
    })
    .catch((err) => {
      res
        .status(401)
        .send({ message: err.message });
    });
}; 
```

Методу `sign` мы передали два аргумента: пейлоуд токена и секретный ключ подписи:

Скопировать кодJAVASCRIPT

```
const token = jwt.sign({ _id: user._id }, 'some-secret-key'); 
```

Пейлоуд токена — зашифрованный в строку объект пользователя. Для шифрования в пейлоуд можно передать сколько угодно информации. Но ни к чему занимать трафик и отправлять лишние данные. Мы рекомендуем шифровать только самое необходимое — идентификатор. Его достаточно, чтобы однозначно определить пользователя.

У метода `sign` есть третий необязательный параметр — объект опций. Полный список опций описан в документации модуля `jsonwebtoken`. Нас интересует одна — `expiresIn`. Это время, в течение которого токен остаётся действительным. Можно передать число, тогда метод `sign` сочтёт его за количество секунд:

Скопировать кодJAVASCRIPT

```
const token = jwt.sign(
  { _id: user._id },
  'some-secret-key',
  { expiresIn: 3600 } // токен будет просрочен через час после создания
); 
```

Можно передать строку, которая состоит из числа и буквы. Буква означает единицы измерения — миллисекунды, минуты, часы или дни:

Скопировать кодJAVASCRIPT

```
expiresIn: '120ms' // 120 миллисекунд
expiresIn: '15m' // 15 минут
expiresIn: '2h' // 2 часа
expiresIn: '7d' // 7 дней 
```

Если опцию `expiresIn` не передать вовсе, токен никогда не будет просрочен.