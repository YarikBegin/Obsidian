
[[React]]

В предыдущих примерах мы всё время приводили JSX в качестве основного «строительного материала» для «Реакта». На самом деле JSX — лишь «синтаксический сахар», за которым скрываются вызовы одной единственной, но очень важной функции в «Реакте». Это функция `React.createElement`, и с помощью неё в «Реакте» создаются виртуальные узлы (англ. virtual nodes).

В самом начале мы подключали «Бабель» — как раз, чтобы трансформировать JSX во множество вызовов `React.createElement`. Кстати, в [онлайн-версии «Бабеля»](https://babeljs.io/repl#?browsers=defaults%2C%20not%20ie%2011%2C%20not%20ie_mob%2011&build=&builtIns=false&corejs=3.21&spec=false&loose=false&code_lz=DwEwlgbgUABDDGAbAhgZ1QOWQWwKYF4AiABzADsBrGAKwFdsAjAe0NhibIGFEx4L8A3gAoAlDHwA-BB1RNEuAHSImAcyEByJLwoBCdSIC-UCW0ACIID4QQOwg5wEwggaRBAnCAxgDCYEEQQNwg5wLwgwAPSuUP7gECZAA&debug=false&forceAllTransforms=false&shippedProposals=false&circleciRepo=&evaluate=false&fileSize=false&timeTravel=false&sourceType=script&lineWrap=true&presets=env%2Creact&prettier=false&targets=&version=7.18.10&externalPlugins=&assumptions=%7B%7D) можно наглядно увидеть, как происходят такие трансформации — просто введите исходный код, и результат сразу появится в правом окне.

Скопировать кодJAVASCRIPT

```
// JSX-код
<div
    className="pink jumbo"
    onClick={() => console.log('click!')}
>
  розовый <b>слон</b>
</div> 
```

Скопировать кодJAVASCRIPT

```
// Код после транспиляции
React.createElement(
    // Имя тега или компонента
    'div',
    // Атрибуты или пропсы
    {
          className: 'pink jumbo',
          onClick: () => console.log('click!')
    },
    // Первый дочерний узел (строка)
    'розовый ',
    // Второй дочерний узел (ещё один элемент)
    React.createElement(
        'b',
        null,
        'слон'
    )
); 
```

Каждый элемент в JSX трансформируется в один вызов `React.createElement`. Эта функция принимает два основных аргумента: имя тега или указатель на компонент, а также объект, содержащий все атрибуты и пропсы. Последующие аргументы (их число не ограничено) перечисляют все непосредственные дочерние узлы.

Чаще всего среди дочерних узлов находятся:

-   другие вызовы `React.createElement`;
-   строки текста;
-   JavaScript-выражения, возвращающие что-то из вышеперечисленного или «пустой» узел (это может быть `null`, `undefined` или `false`).

В результате вызова функции `React.createElement` внутри движка «Реакта» создаётся «Реакт»-элемент — главная молекула «организма „Реакта“»: JavaScript-объект, содержащий данные, которые были переданы в функцию. В упрощённом виде структура этого элемента выглядит так:

Скопировать кодJAVASCRIPT

```
{
    type: 'div',
    props: {
        className: 'pink jumbo',
        onClick: () => console.log('click!'),
        children: [
            'Розовый',
            {
                type: 'b',
                children: ['слон']
            }
        ],
    },
} 
```

Обратите внимание, что объект `children` — часть объекта `props`. В дальнейшем нам это пригодится, когда мы будем работать с компонентами, в которых часть содержимого не только описывается внутри самих компонентов, но и может быть задана извне.

В конечном итоге формируется древовидная структура объектов, где один корневой объект ссылается на несколько дочерних через своё поле `children` и так далее. Именно эта структура затем передаётся в функцию `ReactDOM.render`, где происходит самое интересное.

«Реакт» использует эту структуру данных для двух целей.

**Во-первых,** на её основе строятся и вставляются на страницу реальные DOM-элементы (с помощью `document.createElement` и `appendChild`), а также вызывается рендер компонентов. В результате рендера компонентов эта структура, а с ней и реальный DOM, «обрастают» дополнительными ветвями, структура которых была описана в компонентах.

**Во-вторых,** «Реакт» использует эти данные для хранения виртуального DOM (англ. Virtual DOM) — виртуальной копии текущей структуры DOM. При последующих рендерах обновлённая структура поэлементно сравнивается с последней сохранённой копией, что позволяет «Реакту» определить минимальное необходимое количество изменений и применить эти изменения в реальном DOM.

Это необходимо, потому что почти любые операции с DOM — узкое место в JavaScript. Алгоритм «Реакта», который называется “reconciliation” (англ. «согласование»), сводит количество этих операций к минимуму. Сравнение двух даже сложных JavaScript-объектов во много раз быстрее, чем аналогичные операции над DOM-деревом. Это позволяет «Реакту» сохранить высокую скорость работы в приложениях с большим количеством меняющихся данных.