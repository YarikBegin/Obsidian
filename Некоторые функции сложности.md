[[JavaScript]]

В этом уроке рассмотрим несколько основных функций сложности. К каждой из них мы подобрали пример кода — так станет понятнее.

## Константная сложность О(1)

Сложность алгоритма не зависит от входных данных. Для примера возьмём арифметическое действие:

Скопировать кодJAVASCRIPT

```
function div(a, b) {
  return (a - (a % b)) / b;
} 
```

Объём работы здесь не зависит от значений `a` и `b` .

## Логарифмическая сложность О(log(n))

Сложность растёт логарифмически –– на каждом шаге мы в несколько раз уменьшаем количество обрабатываемых данных. В информатике часто работают с логарифмами по основанию два, то есть уменьшают объём данных вдвое. Но на сложность алгоритма основание не влияет.

Рассмотрим бинарный поиск индекса элемента по отсортированному массиву. На каждом шаге мы берём элемент из середины отсортированного массива и проверяем, равен ли он искомому. Если элемент больше, продолжаем искать в левой части. Если меньше –– в правой. И так до тех пор, пока не найдём нужный элемент.

Скопировать кодJAVASCRIPT

```
function binarySearch(sortedNumbers, n) {
    // Определяем точки начала и конца поиска
  let start = 0;
  let end = sortedNumbers.length;
    
  while (start < end) {
        // Находим элемент в середине массива
    const middle = Math.floor((start + end) / 2);
    const value = sortedNumbers[middle];
    
        // Сравниваем аргумент со значением в середине массива
    if (n == value) {
      return middle;
    }

        // Если аргумент меньше, чем серединное значение, разделяем массив пополам
        // Теперь конец массива — это его бывшая середина
    if (n < value) {
      end = middle;
        // Иначе началом массива становится элемент, идущий сразу за «серединой»
    } else {
      start = middle + 1;
    }
  }
  
    // если искомое число не найдено, возвращаем -1
  return -1;
} 
```

При каждой итерации массив делится пополам. Если изначально длина массива — 1024, то на второй итерации элементов останется 512, затем — 256, потом 128 и так далее.

То есть, для массива из 1024 элементов понадобится максимум `log2(1024) = 10` шагов. И число шагов будет расти очень медленно по сравнению с размером массива. Например, чтобы найти число в отсортированном массиве размером в 1000 раз больше, понадобится всего в 2 раза больше шагов `log2(1024000) = 19.96`.

## Линейная сложность О(n)

Эту сложность мы получаем, когда создаём цикл по массиву элементов или вызываем метод, который перебирает массив. Она растёт прямо пропорционально количеству данных.

Линейную сложность применяют, например, когда надо найти минимум (или максимум) в несортированном массиве. Для начала идём по массиву и сравниваем числа. Если встречаем больше или меньше записанного минимума и максимума, перезаписываем их на новые.

Скопировать кодJAVASCRIPT

```
function minMax(numbers) {
    // Присваиваем переменным min и max первый элемент массива
  let min = numbers[0];
  let max = numbers[0];
 
  for (let i = 1; i < numbers.length; i++) {
    const n = numbers[i];

        // Сравниваем элемент с min
    if (n < min) {
      min = n;
    }

        // Сравниваем элемент с max
    if (n > max) {
      max = n;
    }
  }
    
    // Возвращаем найденную пару значений 
  return { min, max };
} 
```

Количество операций линейно зависит от длины массива: если массив увеличится вдвое, то и количество операций тоже вырастет в два раза.

## Квадратичная сложность O(n^2)

Квадратичная сложность растёт быстро: при увеличении данных в 100 раз, объём вычислений вырастет в 10000 раз. На больших данных алгоритм с такой сложностью работает медленно.

Пример –– поиск всех комбинаций элементов из двух массивов. Для каждого элемента из первого массива мы пробегаем по всему второму массиву и складываем все пары в результирующий массив.

Скопировать кодJAVASCRIPT

```
function combinations(arr1, arr2) {
    // Создаём массив для результата
  const result = [];

    // Запускаем вложенные циклы и формируем все возможные пары
  for (let i = 0; i < arr1.length; i++) {
    for (let j = 0; j < arr2.length; j++) {
      result.push([arr1[i], arr2[j]]);
    }
  }

  return result;
} 
```

Квадратичная сложность — частный случай полиномиальной — `O(n^k)`. Если цикл вложен в другой цикл, а тот — в третий, зависимость будет кубической — `O(n^3)`. Если 4 цикла вложены друг в друга — `O(n^4)`, и так далее.

Бывают и другие функции сложности, но здесь мы привели только основные. Если не терпится познакомиться с остальными функциями сейчас, — ищите дополнительные материалы в следующем уроке.