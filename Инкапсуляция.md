[[Объектно-ориентированное программирование. Введение]]

Мы живём в мире гаджетов, но не обязаны в них разбираться. Не важно, какие процессы выполняются в компьютере при запуске — достаточно нажать кнопку ″Power″, чтобы он заработал. Поэтому с точки зрения программирования кнопка включения — часть интерфейса ПК.

Это и есть инкапсуляция — когда внутренняя реализация устройства скрыта от внешнего мира. Пользователю просто и удобно управлять таким гаджетом: вся его сложность спрятана «под капотом».

## Пользовательский интерфейс

Разработчики часто говорят о «пользовательском интерфейсе» — визуальном представлении программы: меню, кнопках, переключателях, полях ввода и др. Он нужен, чтобы любой желающий мог с ней взаимодействовать. В итоге получается прослойка между программным кодом и пользователем.

У каждого сложного устройства должен быть пользовательский интерфейс, чтобы сделать его удобнее в использовании. Завести автомобиль ключом зажигания гораздо проще, чем открыть капот и пытаться разобраться, как запустить двигатель.

## Принцип интерфейсов в ООП

К объектам в ООП-коде применим тот же принцип. Внешние объекты интерфейса — его публичные методы, которые можно смело вызывать во внешнем коде.

У объектов есть и приватные методы и свойства. Их отличие от публичных в том, что их не используют во внешнем коде — они только для внутренней реализации объекта. Мы подробно это разберём в примерах ниже.

Только недавно приватные методы и свойства были реализованы в JS на уровне языка. Раньше их только номинально считали приватными или как-нибудь эмулировали эту функциональность.

Мы расскажем об эмуляции: она более распространена.

## Приватные методы и свойства

Между разработчиками существует негласное соглашение — именовать приватные свойства и методы знаком нижнего подчёркивания `_`. Так все поймут, что свойство внутреннее и использовать его напрямую во внешнем коде нежелательно:

Скопировать кодJAVASCRIPT

```
class Car {
    constructor(maxGasTankValue, fuelConsumption) {
        this._gasTankValue = 0;
        this._maxGasTankValue = maxGasTankValue;
        this._fuelConsumption = fuelConsumption; // литров на 100км
    }

    _getAvailableGasValue(gasValue) {
        if (gasValue < 0) return 0;
        if (gasValue > this._maxGasTankValue) return this._maxGasTankValue;
        return gasValue;
    }
    
    refuel(gasValue) {
        this._gasTankValue = this._getAvailableGasValue(gasValue);
    }
    
    getDistance() {
        return this._gasTankValue / this._fuelConsumption * 100;
    }
}

const car = new Car(70, 9);
car.refuel(45);

console.log(car._gasTankValue); // 45. Свойство на самом деле не приватное. Его можно легко изменить
console.log(car.getDistance()); // 500 
```

В этом примере ничто не мешает установить отрицательное количество бензина выражением `car._gasTankValue = -1`. Такое прямое вмешательство во внутреннюю реализацию приведёт к ошибке в работе объекта.

Но таких ошибок можно избежать. Когда работаете с объектом класса, не используйте приватные методы и не обращайтесь, и ничего не записывайте в приватные свойства извне.

## Действительно приватные свойства и методы

Можно создавать и действительно приватные методы и свойства. Для этого используется символ решётки `#` в названии.

И если `_` нужно лишь для условного обозначения свойства или метода как приватного, то `#` действительно делает его таковым:

Скопировать кодJAVASCRIPT

```
class Car {
    #gasTankValue
    #maxGasTankValue
    #fuelConsumption
    constructor(maxGasTankValue, fuelConsumption) {
        this.#gasTankValue = 0;
        this.#maxGasTankValue = maxGasTankValue;
        this.#fuelConsumption = fuelConsumption; // литров на 100км
    }

    #getAvailableGasValue(gasValue) {
        if (gasValue < 0) return 0;
        if (gasValue > this.#maxGasTankValue) return this.#maxGasTankValue;
        return gasValue;
    }
    
    refuel(gasValue) {
        this.#gasTankValue = this.#getAvailableGasValue(gasValue);
    }
    
    getDistance() {
        return this.#gasTankValue / this.#fuelConsumption * 100;
    }
}

var car = new Car(70, 9); 
// Эта строка приведёт к ошибке. Доступ к приватным свойствам извне отсутствует
car.#gasTankValue = -10  
```

Новый синтаксис `#` не поддерживается многими браузерами. Для полноценной работы нужны специальные программные средства. Они трансформируют код в новом синтаксисе в код по старому стандарту. Мы расскажем о `#` позже, а пока будем использовать `_`.

В отличие от приватных полей, обозначенных через `_`, действительно приватные поля класса необходимо объявлять отдельно. Это можно сделать перед вызовом `constructor()`.

В примере выше у класса `Car` два публичных метода. Метод `refuel` устанавливает количество горючего, `getDistance` получает дистанцию, которую проедет автомобиль на заранее установленном количестве бензина.

Создадим объект класса:

Скопировать кодJAVASCRIPT

```
const car = new Car(54, 5.5) 
```

Можно вызвать метод `car.refuel(100)` заправки автомобиля или метод `car.getDistance()` возврата количества километров, на которые хватит топлива.

Метод `refuel` использует приватный метод `_getAvailableGasValue`. Он не позволит поместить в приватное же свойство `_gasTankValue`:

-   отрицательное количество литров бензина;
-   количество, которое превышает объём бака автомобиля. Его объём мы установили первым параметром при вызове `new Car()`.

Когда мы используем публичные методы объекта, мы одновременно вызываем приватные методы и читаем или записываем данные в приватные свойства. Но эту информацию знать необязательно: приватные свойства инкапсулированы внутри класса. Часть их данных и функциональности скрыты от внешнего окружения.

Так инкапсуляция представила объект из 3 методов и 3 свойств как интерфейс из 2 публичных методов, с которыми просто работать.