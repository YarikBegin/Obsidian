[[Объектно-ориентированное программирование. Введение]]

В прошлом уроке для каждого объекта создавалась и хранилась в памяти функция `like`. И каждая из них — самостоятельная: `song1.like === song2.like // false`.

Это ресурсозатратно. Каждая функция `like` выполняет похожее действие: заменяет состояние поля `isLiked` своего объекта на противоположное. Поэтому логичнее создать одну функцию `like` и позволить ей изменять свойства любого объекта, который вызывает её как метод.

Для начала объявим `like` вне контекста функции `createSong` и передадим её новым объектам по ссылке:

Скопировать кодJAVASCRIPT

```
function like() {

}

function createSong(title, artist) {
    const newSong = {
        title,
        artist,
        isLiked: false,
        like: like
    }

    return newSong;
} 
```

Теперь у объектов в атрибуте `like` будет ссылка на единственную функцию, к которой у них есть доступ: `song1.like === song2.like //true`.

Мы не случайно убрали код из тела `like`. До этого каждая новая функция `like` ссылалась на свой объект `newSong`. Поэтому возникает вопрос: как сделать её универсальной, как позволить `like` работать со всеми объектами, которые создаёт функция `createSong`?

Чтобы решить эту проблему, нужно познакомиться с `this`.

Свойство `this` — это ключевое слово, которое доступно внутри любой функции. В зависимости от способа вызова функции `this` принимает разные значения. Мы разберём все 5 возможных вариантов в следующем спринте.

А начнём с нашего примера:

Скопировать кодJAVASCRIPT

```
function like() {
    this.isLiked = !this.isLiked;
}

function createSong(title, artist) {
    const newSong = {
        title,
        artist,
        isLiked: false,
        like: like
    }

    return newSong;
}

const song1 = createSong('Футбольный мяч', 'Антоха MC');

song1.like(); // внутри функции like this — это song1

console.log(song1.isLiked); // true — сработало 
```

Здесь `this` — объект, на котором вызвана функция. Если функцию вызывают как метод объекта, свойство `this` хранит ссылку на объект, на котором она вызвана:

Скопировать кодJAVASCRIPT

```
const obj = {
    prop: 'Свойство',
    method: function () {
        console.log(this); // выведем значение this
    }
}

// { prop: "Свойство", method: ƒ } — это и есть объект obj, на котором была вызвана функция method.
obj.method();  
```

![image](https://pictures.s3.yandex.net/resources/JS4_2___1__3_1560772888_1589621901.jpg)

_В консоль выводится `obj` — объект, на котором вызван метод `method`_

В нашем примере функция `like` вернёт значение свойства `isLiked` объекта `song1`, на котором она вызвана как метод:

Скопировать кодJAVASCRIPT

```
/* здесь внутри функции like
значением this будет объект song1,
так как метод вызван именно на нём */

song1.like(); 
```

Значение `this` зависит только от того, на каком объекте вызвана функция, а не в каком объекте она хранится.

Подумайте, каким будет значение `this` внутри функции `like` здесь:

Скопировать кодJAVASCRIPT

```
song2.like();
song3.like(); 
```

Ещё раз: если функция вызвана как метод объекта, то в момент вызова значение `this` внутри неё — это объект, на котором она вызвана.

Поэтому ответ таков:

Скопировать кодJAVASCRIPT

```
song2.like(); // здесь this будет song2
song3.like(); // а здесь this будет song3 
```

Три урока теории позади — начинаем практику.