
[[React]]

Продолжим изучать встроенные методы класса `React.Component`. В этом уроке расскажем о методах, которые позволяют управлять «жизненным циклом» (англ. lifecycle) классовых компонентов и тем самым лучше контролировать их поведение. Например, выполнить определённый код в заранее заданный момент.

Каждый компонент в течение своего жизненного цикла может быть монтирован (англ. mount), обновлён (англ. update) и размонтирован (англ. unmount).

**Монтирование** происходит, когда HTML-дерево компонента вставляется движком «Реакта» в DOM.

**Обновление** происходит в одном из трёх случаев:

-   если произошёл рендер родительского компонента,
-   если изменилось внутреннее состояние в результате вызова `this.setState`,
-   если обновление было инициировано вызовом встроенного метода `this.forceUpdate`.

**Размонтирование** происходит, когда HTML-дерево компонента удаляется из DOM.

Каждому из этих событий соответствует один из трёх методов жизненного цикла: `componentDidMount`, `componentDidUpdate` и `componentWillUnmount`.

Как и метод `render`, это методы обратного вызова: в отличие от `setState` вы никогда не будете вызывать их вручную, однако вы будете описывать их внутри своих компонентов, чтобы в нужный момент они были вызваны изнутри самого движка «Реакта» — как колбэки.

![image](https://pictures.s3.yandex.net/resources/S10_2_02_v04_components_1593878819.png)

_Можно [скачать интерактивный вариант схемы на GitHub](https://github.com/wojtekmaj/react-lifecycle-methods-diagram). Там отражены менее популярные методы работы с жизненным циклом компонентов и соответствующие ссылки на документацию React на русском языке_

Чаще всего методы жизненного цикла используются для описания так называемых «побочных эффектов» (англ. side effects). В процессе «жизнедеятельности» компонент помимо непосредственно отрисовки может взаимодействовать с различными API, подписываться на глобальные события, обращаться к серверу за данными и т.д. Именно это принято называть его побочными эффектами или просто эффектами.

Предположим, что мы хотим сделать приложение, в котором будет доступен режим кастомизированного курсора: с помощью чекбокса на страницу будет добавляться компонент с картинкой, следующей за движениями мыши.

Нам понадобятся два компонента: корневой компонент `App` с чекбоксом и находящийся внутри него компонент `NeonCursor`, который будет монтироваться, только когда чекбокс отмечен.

Сперва опишем компонент `App`.

Скопировать кодJSX

```
// Корневой компонент приложения
class App extends React.Component {
  constructor(props) {
    super(props);

    this.state = { isCustomCursor: false };
  }

  handleChange = () => {
    this.setState({
      isCustomCursor: !this.state.isCustomCursor,
    });
  };

  render() {
    return (
      <>
        <label>
          <input type="checkbox" onChange={this.handleChange} />
          — Включить неоновый курсор
        </label>
        {this.state.isCustomCursor && <NeonCursor />}
      </>
    );
  }
} 
```

Самое интересное происходит в этой строчке:

Скопировать кодJSX

```
{this.state.isCustomCursor && <NeonCursor />} 
```

Здесь мы используем оператор `&&` для создания условной логики: компонент `NeonCursor` будет включён в структуру JSX только тогда, когда условие перед оператором (`this.state.isCustomCursor`) истинно. Изначально значение этого поля равно `false`, но когда пользователь установит галочку чекбокса, будет вызван метод `this.setState`, который его изменит. Это приведёт к монтированию компонента `NeonCursor`. Если пользователь снимет галочку, условие снова изменится и компонент будет удалён из дерева JSX и, соответственно, из DOM.

Теперь опишем сам компонент `NeonCursor`.

Скопировать кодJSX

```
// Компонент, отвечающий за кастомизированный курсор
class NeonCursor extends React.Component {
  constructor(props) {
    super(props);

    this.state = { top: 0, left: 0 };
  }

    // Метод будет вызван сразу после монтирования: создаём эффекты
  componentDidMount() {
    document.addEventListener('mousemove', this.handleMouseMove);
    document.documentElement.classList.add('no-cursor');
  }

    // Метод будет вызван непосредственно перед размонтированием: удаляем эффекты
  componentWillUnmount() {
    document.documentElement.classList.remove('no-cursor');
    document.removeEventListener('mousemove', this.handleMouseMove);
  }

  handleMouseMove = (event) => {
    this.setState({
      top: event.pageY,
      left: event.pageX,
    });
  };

  render() {
    return (
      <img
        src="./cursor.png"
        width="30"
        style={{
          position: 'absolute',
          top: this.state.top,
          left: this.state.left,
          pointerEvents: 'none',
        }}
      />
    );
  }
} 
```

В этом компоненте описаны два метода его жизненного цикла. Метод `componentDidMount` будет вызван как только компонент монтируется в DOM: в нём мы подписываемся на событие `mousemove` документа, а также добавляем документу CSS-класс, отключающий стандартный курсор на всех элементах страницы. Кстати, этот класс выглядит так:

Скопировать кодCSS

```
/* Элемент с классом no-cursor и все вложенные в него элементы */
.no-cursor, .no-cursor * { cursor: none; } 
```

Когда пользователь снимет галочку чекбокса, наш компонент размонтируется, и нам очень важно «подчистить» (англ. cleanup) произведённые им эффекты: удалить слушатель `mousemove` и снять с документа CSS-класс, чтобы снова включился стандартный курсор. Эти действия мы производим в методе `componentWillUnmount`.

В этом методе команды вызываются в обратном порядке по отношению к методу `componentDidMount` — это стандартная практика называется принцип «шнурков и ботинок». Мы всегда сначала надеваем ботинки, а затем завязываем шнурки, а когда собираемся их снять, всё происходит наоборот.

Благодаря подписке на событие `mousemove` каждое движение курсора вызывает метод `handleMouseMove`, который обновляет внутреннее состояние компонента с помощью `this.setState`, что влечёт за собой вызов `render` с новыми значениями и приводит к обновлению DOM: элемент `<img>` получает новые координаты и перемещается по экрану.

Вся логика готова. Добавим компонент приложения на страницу:

Скопировать кодJSX

```
ReactDOM.render(<App />, document.querySelector('#root')); 
```

Неоновый курсор к вашим услугам.