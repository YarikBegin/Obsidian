
[[Наследование]]

В прошлом уроке мы доделали карточки сообщений: проджект-менеджер доволен. Но это ещё не весь интерфейс чата. Карточки должны различаться внешне и по функциональности.

Дизайнер передал, что пользователь увидит свои сообщения справа и без аватарки, собеседника — слева и с аватаркой. В будущем различий между карточками станет больше, но это пока проектируют.

![image](https://pictures.s3.yandex.net/resources/Untitled_1590945369.png)

_Уже похоже на привычный чат_

Чтобы реализовать решение дизайнера, нужно перестроить класс `Card`. Код организован по принципам ООП, поэтому можно применить наследование. Мы оставим в родительском классе общие данные и функциональность, а уникальные фичи унаследуем в дочерних.

Получится такая структура:

Скопировать кодJAVASCRIPT

```
class Card {
  // здесь общие данные и функциональность
}

class UserCard extends Card {
  // данные и функциональность карточки пользователя
}

class DefaultCard extends Card {
  // данные и функциональность карточки собеседника
} 
```

Создадим два html-элемента `template` с разной вёрсткой под каждый тип карточки. А родительский класс мы уже на прошлых уроках подготовили к работе с разными селекторами:

Скопировать кодHTML

```
<template class="card-template card-template_type_user">
  <div class="card">
    <!-- вёрстка карточки пользователя, она без картинки-->
  </div>
</template>

<template class="card-template card-template_type_default">
  <div class="card">
    <!-- вёрстка карточки собеседника -->
  </div>
</template> 
```

Теперь передадим в конструктор селекторы классов `card-template_type_user` и `card-template_type_default`. Методы для получения разметки и генерации карточек уже написаны. Но разметка карточек теперь разная, поэтому переопределим эту функциональность в дочерних классах.

Массив `messageList` тоже должен измениться. Теперь нужно маркировать сообщение пользователя, чтобы отличить его от сообщения собеседника. Иначе мы не поймём, какую карточку для какого сообщения создавать.

Поэтому добавим в объект сообщений пользователя ключ `isOwner` со значением `true`, чтобы писать проверки на основе этого параметра:

Скопировать кодJAVASCRIPT

```
const messageList = [
  {
    image: 'https://code.s3.yandex.net/web-code/card__image.jpg',
    text: 'Привет, нам срочно требуется доработать чат!'
  },
  {
    text: 'Это карточка пользователя',
    isOwner: true // добавили свойство isOwner сообщению пользователя
  },
  {
    image: 'https://code.s3.yandex.net/web-code/card__image.jpg',
    text: 'Ответ!'
  }
]; 
```

Теперь нужно определить, какие свойства и методы останутся в родительском классе, а какие перейдут в дочерние.

## Размещение методов в классах

Определим, в каких классах будут методы:

-   `_getTemplate` — в родительском. Метод только получает разметку шаблона по определённому селектору. Это нужно для каждой карточки.
-   `_setEventListeners` и `_handleMessageClick` — в родительском. Методы назначают функциональность карточек в зависимости от событий. События нужны всем карточкам.
-   `generateCard` — в дочерних. Метод наполняет карточки данными и функциональностью. У нас два типа карточек с разными данными, поэтому для каждой нужен свой метод.

Код получится таким:

Скопировать кодJAVASCRIPT

```
class Card {
  constructor() {
    // с конструктором разберёмся позже
  }

  _getTemplate() {
    // код _getTemplate
  }

  _setEventListeners() {
    // код _setEventListeners
  }

  _handleMessageClick() {
    // код _handleMessageClick
  }
}

class UserCard extends Card {
  constructor() {
    // с конструктором разберёмся позже
  }

  generateCard() {
    // код generateCard
  }
}

class DefaultCard extends Card {
  constructor() {
    // с конструктором разберёмся позже
  }

  generateCard() {
    // код generateCard
  }
} 
```

Код методов почти прежний. Но когда в дочерних классах мы вызываем методы родительского, нужно вместо `this` написать `super`, ведь теперь мы обращаемся к родителю.

Код методов изменится аналогично. Такой он у метода `generateCard` в классе `UserCard`:

Скопировать кодJAVASCRIPT

```
class UserCard extends Card {
  constructor() {
    // с конструктором разберёмся позже
  }

  generateCard() {
    this._element = super._getTemplate(); // заменили this на super
    super._setEventListeners(); // заменили this на super

    this._element.querySelector('.card__paragraph').textContent = this._text;

    return this._element;
  }
} 
```

## Изменение конструкторов родителя и наследников

Сначала разберёмся, какие данные хранить в конструкторах наследников, а какие — в родительском. Сейчас все поля объявлены на уровне `Card`. Но не все они нужны дочерним классам. Так у карточки пользователя нет аватарки, а у родительской `Card` — есть.

Теперь нужно передать дочерним классам селектор, с которым работает каждая карточка. Для этого в конструкторе родительского оставляем только один параметр — этот селектор. Ключевым словом `super` с аргументом-селектором его и передают дочерним классам. Кроме селектора из родителя в конструкторы наследников записывают другие данные:

Скопировать кодJAVASCRIPT

```
class Card {
  constructor(templateSelector) { // теперь здесь один параметр — селектор
    this._templateSelector = templateSelector;
  }

    // далее — все методы класса
}

class UserCard extends Card {
    constructor(data, templateSelector) {
    // ключевым словом super вызываем конструктор родительского
    // класса с единственным аргументом — селектором темплейта
    super(templateSelector);

    // у карточки пользователя есть только текст
    this._text = data.text;
    }

    // далее — метод generateCard
}

class DefaultCard extends Card {
    constructor(data, templateSelector) {
    // аналогично вызываем конструктор родителя
    super(templateSelector);

    // у карточки собеседника есть текст и аватар
    this._text = data.text;
    this._image = data.image;
    }

    // далее — метод generateCard
} 
```

## Создание экземпляров классов

Осталось добавить условие перебора массива `messageList`. В зависимости от значения ключа `isOwner` создаются экземпляры разных классов:

Скопировать кодJAVASCRIPT

```
messageList.forEach((item) => {
  // Если значение isOwner === true,
  // создаётся экземпляр UserCard,
  // иначе DefaultCard

  const card = item.isOwner
    ? new UserCard(item, '.card-template_type_user')
    : new DefaultCard(item, '.card-template_type_default');

    const cardElement = card.generateCard();

    document.body.append(cardElement);
}); 
```

Посмотрите [итоговый код](https://repl.it/@praktikum/lesson-5) урока, а потом уже переходите к заданиям.