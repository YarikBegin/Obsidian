[[Продвинутый JavaScript]]

Асинхронность — это не только про многозадачность, но и про путаницу с порядком выполнения операций.

Рассмотрим пример:

Скопировать кодJAVASCRIPT

```
console.log('Это сообщение появится в консоли первым');

setTimeout(function () {
  console.log('А это — третьим');
}, 1);

console.log('Это сообщение появится вторым'); 
```

Разберём, почему так происходит.

Сначала движок просто выполняет функцию `console.log`. Для этого он отправляет её в специальный стек вызовов — call stack.

Дальше он натыкается на задачу по установке таймера. Сам движок отсчитывать время не умеет — этим занимается браузер. Поэтому движок «стучится» в браузерный API и просит: «Поставь таймер на 1 мс, после чего скажи мне выполнить вот этот колбэк».

Всё, запрос в Web API ушёл, так что движок взялся за свои дела — продолжил выполнять инструкции, то есть отправил в стек вызовов, или колстек, ещё один вывод в консоль.

Дальше происходит событие — 1 миллисекунда прошла. Поэтому движку приходит сообщение от API, что код колбэка можно исполнять. Эта задача встаёт в специальную очередь вызовов, или очередь колбэков. Если движок чем-то занят, когда ему приходит колбэк, он сначала закончит со своими делами, а потом займётся выполнением задач из очереди колбэков.

### Как устроен колстек

Все инструкции попадают на выполнение в стек вызовов. Это происходит так:

Скопировать кодJAVASCRIPT

```
console.log('Аты-баты, шли солдаты');
console.log('Аты-баты, на базар'); 
```

1.  В колстек попадает задача: «Выведи на экран строку „Аты-баты, шли солдаты“».
2.  Задача выполняется — строка выводится.
3.  В колстек приходит следующая задача: «Выведи на экран строку „Аты-баты, на базар“»
4.  Задача выполняется — ещё одна строка выводится.

Но задачи могут быть сложнее — они могут порождать выполнение других задач:

Скопировать кодJAVASCRIPT

```
function businessBeforePleasure() {
  function business() {
    console.log('Сделал дело');
  }

  function pleasure() {
    console.log('Гуляй смело');
  }

  business();
  pleasure();
}

businessBeforePleasure(); 
```

Тут колстек заполняется сложнее:

1.  В колстек попадёт задача «Выполни функцию `businessBeforePleasure`».
2.  Дальше движок отправится в тело функции `businessBeforePleasure`.
3.  В колстек попадёт задача выполнить код функции `business` — вызов этой функции окажется в колстеке «поверх» функции `businessBeforePleasure`.
4.  Движок начнёт выполнять код функции `business`: отправит в колстек задачу «Выведи в консоль строку „Сделал дело“».
5.  Внутри функции `business` больше нет задач, а значит, её можно исполнить. Это и происходит: в консоль выводится строка «Сделал дело», а из колстека уходят вызов `console.log` и вызов функции `business`.
6.  Затем в колстек попадает функция `pleasure`, а поверх неё — вызов `console.log` с аргументом «Гуляй смело».
7.  И снова колстек очищается: сначала из него уходит вызов `console.log`, затем — функция `pleasure` и, наконец, функция `businessBeforePleasure`. Колстек становится пустым.

![image](https://pictures.s3.yandex.net/resources/S11_businessBeforePleasure_1592577517.png)

_Как будет меняться колстек_

Таким образом, задачи в колстек поступают как игральные карты из колоды. Если это одна задача, скажем, вызов `console.log`, движок «сдаёт» в колстек одну карту. Если же вы вызываете одну функцию из другой, в колстек эти функции тоже будут попадать как карты: в самом низу колстека окажется самая внешняя функция, выше — первой степени вложенности и так далее.

Если в колстек попала такая «стопка» задач, то и выполняться они будут сверху вниз: сначала из колстека уйдёт самая вложенная функция (верхняя карта в стопке), затем более внешняя.

## Очередь колбэков и цикл событий

Мы рассматривали такой пример:

Скопировать кодJAVASCRIPT

```
console.log('Это сообщение появится в консоли первым');

setTimeout(function () {
  console.log('А это — третьим');
}, 1);

console.log('Это сообщение появится вторым'); 
```

Усложним этот код:

Скопировать кодJAVASCRIPT

```
/* Предупреждение: если запустить этот код в консоли,
вкладка браузера зависнет на несколько минут. Не делайте этого, если
не хотите ждать, пока код закончит работу. */

console.log('Это сообщение появится в консоли первым');

setTimeout(function () {
  console.log('Непонятно, какое по счёту это сообщение');
}, 1);

for (let i = 0; i <= 1000000; i += 1) {
  console.log('Это сообщение нужно показать в консоли миллион раз');
} 
```

Когда появится сообщение «Непонятно, какое по счёту это сообщение»?

Кажется, можно рассуждать так: поскольку миллион раз вывести в консоль строку занимает больше 1 мс, вывод строки «Непонятно, какое по счёту это сообщение» втиснется куда-то между выводами «Это сообщение нужно показать в консоли миллион раз». Но это не так.

Как мы уже выяснили ранее, после ответа от Web API задача попадает в специальную очередь колбэков. Но как движок понимает, когда именно нужно браться за задачи из этой очереди? Тут ему на помощь приходит цикл событий — Event Loop. Он следит за тем, чтобы все функции из колстека были выполнены, и если это случилось, добавляет туда задачи из очереди колбэков.

Рассмотрим в какой последовательности выполнятся задачи в нашем примере:

1.  В колстек по очереди попадают задачи:
    -   выведи в консоль «Это сообщение появится в консоли первым»;
    -   отправь запрос в Web API на установку таймера в 1 мс;
    -   миллион раз покажи в консоли строку «Это сообщение нужно показать в консоли миллион раз».

Каждая задача после выполнения исчезает из колстека, после чего в него попадает следующая задача.

1.  От Web API приходит сигнал о том, что таймер прошёл и колбэк из таймера попадает в очередь колбэков.
2.  После выполнения всех трёх задач колстек становится пустым. Event Loop видит это и отправляет в колстек задачу из очереди колбэков.
3.  Теперь снова начинают выполняться задачи из колстека — в консоль выводится строка «Непонятно, какое по счёту это сообщение».

Таким образом, задача вывести сообщение «Непонятно, какое по счёту это сообщение» выполнится последней, так как Event Loop отправляет задачи из очереди колбэков в колстек только после того, как все задачи из него будут выполнены.

Внимание, вопрос. В каком порядке числа выведутся в консоль?

Скопировать кодJAVASCRIPT

```
console.log(1);

// ставим таймер на 0 миллисекунд
setTimeout(function () {
  console.log(2);
}, 0);

console.log(3); 
```

Неправильный ответ

`1`, `2`, `3`

Эх.

`2`, `1`, `3`

Тоже правильный ответ

`1`, `3`, `2`

Ух! Несмотря на то, что таймер поставлен на 0 миллисекунд, вызов переданного в него колбэка произойдёт асинхронно. После того как отработает весь синхронный код.