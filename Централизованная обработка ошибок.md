[[JavaScript]]

До этого момента мы уделяли мало внимания ошибкам, которые возвращало наше API, и отправляли клиенту ошибку прямо там, где она возникала:

Скопировать кодJAVASCRIPT

```
try {
  payload = jwt.verify(token, 'some-secret-key');
} catch (err) {
  // возникла ошибка,
  // тут же отправим её, выставив статус

  return res
    .status(401)
    .send({ message: 'Необходима авторизация' });
} 
```

Такой способ приводит к тому, что код обработки ошибок дублируется в разных местах. Если мы решим поменять формат возвращаемой ошибки, например, добавить в JSON ещё какое-то поле, нам придётся исправлять код несколько раз.

Чтобы избежать этого, принято обрабатывать ошибки централизованно. Для этого нужно добавить приложению мидлвэр такого вида:

Скопировать кодJAVASCRIPT

```
app.use((err, req, res, next) => {
  // это обработчик ошибки
}); 
```

Он отличается от обработчика запроса тем, что принимает не 3, а 4 параметра. Первый дополнительный параметр — и есть ошибка. Такой обработчик ошибки добавляют в последнюю очередь, после всех `app.use`. Обычно это делают где-то в конце файла app.js:

Скопировать кодJAVASCRIPT

```
// app.js

// весь код app.js

// здесь обрабатываем все ошибки
app.use((err, req, res, next) => {
  res.status(500).send({ message: 'На сервере произошла ошибка' });
});

app.listen(PORT); 
```

Но как перейти в этот обработчик ошибки при её возникновении?

## Вызов next с аргументом

Чтобы передать обработку запроса дальше, мы привыкли вызывать `next` без аргумента. Если `next` при вызове передать аргумент, это произведёт совсем иной эффект — запрос перейдёт в обработчик ошибки:

Скопировать кодJAVASCRIPT

```
// вызов next с любым аргументом
// передаст запрос в обработчик ошибки

next('Аргумент'); 
```

Несмотря на то, что `next` можно передать любой аргумент, лучше передавать ему экземпляр ошибки:

Скопировать кодJAVASCRIPT

```
// вызываем next с аргументом-ошибкой

next(new Error('Ошибка авторизации')); 
```

В обработчике можно использовать сообщение, переданное экземпляру ошибки при создании:

Скопировать кодJAVASCRIPT

```
app.use((err, req, res, next) => {
  res.send({ message: err.message });
});

// { "message": "Ошибка авторизации" } 
```

С сообщением понятно, но как в обработчике ошибки выставить ей правильный статус?

## Выставляем ошибке статус

Самый очевидный способ — записать в экземпляр ошибки дополнительное свойство и вызвать `next`:

Скопировать кодJAVASCRIPT

```
try {
  payload = jwt.verify(token, 'some-secret-key');
} catch (e) {
  const err = new Error('Необходима авторизация'); 
  err.statusCode = 401;

  next(err);
} 
```

Мы используем метод получше — сделаем свои конструкторы ошибок. Самые частые ошибки нашего приложения это:

- 400, когда с запросом что-то не так;
- 401, когда что-то не так при аутентификации или авторизации;
- 404, например, когда мы не нашли ресурс по переданному `_id`;

Сделаем свои конструкторы для этих ошибок.

## Собственные конструкторы ошибок

Для ошибок, которые часто повторяются, удобно использовать свои конструкторы. Простейший конструктор 404 ошибки будет выглядеть так:

Скопировать кодJAVASCRIPT

```
// errors/not-found-err.js

class NotFoundError extends Error {
  constructor(message) {
    super(message);
    this.statusCode = 404;
  }
}

module.exports = NotFoundError; 
```

Всё, что делает этот конструктор, — наследует от стандартной ошибки и выставляет свойство `statusCode`. После создания конструктора `NotFoundError`, его можно импортировать в другие места кода и использовать вместе с инструкцией `throw`:

Скопировать кодJAVASCRIPT

```
const NotFoundError = require('./errors/not-found-err');

module.exports.getProfile = (req, res, next) => User
  .findOne({ _id: req.params.userId })
  .then((user) => {
    if (!user) {
      // если такого пользователя нет,
      // сгенерируем исключение
      throw new NotFoundError('Нет пользователя с таким id');
    }

    res.send(user);
  })
  // ... 
```

Инструкция `throw` генерирует исключение и обработка кода переходит в следующий блок `catch`, поэтому не забудьте его добавить. Это можно сделать изящно:

Скопировать кодJAVASCRIPT

```
const NotFoundError = require('./errors/not-found-err');

module.exports.getProfile = (req, res, next) => User
  .findOne({ _id: req.params.userId })
  .then((user) => {
    if (!user) {
      throw new NotFoundError('Нет пользователя с таким id');
    }

    res.send(user);
  })
  .catch(next); // добавили catch 
```

Такая запись `catch` эквивалентна следующей:

Скопировать кодJAVASCRIPT

```
.catch(err => next(err)); 
```

Получается, что `next` будет вызван с аргументом-ошибкой и запрос перейдёт в обработчик ошибки, но уже со статусом и сообщением:

Скопировать кодJAVASCRIPT

```
app.use((err, req, res, next) => {
  res.status(err.statusCode).send({ message: err.message });
}); 
```

## Три важных правила централизованной обработки ошибок

**1. Всегда завершайте цепочки промисов блоком `catch`.**

Передавайте в `catch` функцию `next` и добавляйте обработчик ошибки где-то в конце app.js. Если цепочка промисов не завершена блоком `catch`, это приведёт к так называемому Unhandled promise rejection (англ. «необработанное отклонение промиса»). В будущих версиях Node.js — Node завершит свою работу и приложение упадёт.

**2. Не используйте `throw` в завершающих блоках `catch`.**

`Throw` переводит обработку в следующий блок `catch`. Если использовать `throw` в последнем блоке `catch`, ему будет некуда переходить и возникнет Unhandled promise rejection.

**3. Если в обработчик пришла ошибка без статуса, возвращайте ошибку сервера.**

Мы создали свои конструкторы ошибок. Теперь, когда нужно вернуть ошибку клиенту, мы конструируем экземпляр нужной ошибки и генерируем исключение с помощью `throw`. `Throw` переводит обработку в блок `catch`, где его поджидает `next`. Кажется, всё в порядке, но есть один момент: обработка может перейти в блок `catch` не по причине того, что мы использовали `throw`, а по какой-то другой. Например, исключение может возникнуть при обращении в базу данных или наш код может просто-напросто упасть. Если ошибка сгенерирована не нами, у неё не будет свойства `statusCode`:

Скопировать кодJAVASCRIPT

```
app.use((err, req, res, next) => {
  console.log(err.statusCode); // undefined
}); 
```

В этом случае будем считать произошедшее ошибкой сервера, возвращать 500 статус и стандартное сообщение:

Скопировать кодJAVASCRIPT

```
app.use((err, req, res, next) => {
  // если у ошибки нет статуса, выставляем 500
  const { statusCode = 500, message } = err;

  res
    .status(statusCode)
    .send({
      // проверяем статус и выставляем сообщение в зависимости от него
      message: statusCode === 500
        ? 'На сервере произошла ошибка'
        : message
    });
}); 
```