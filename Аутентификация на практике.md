[[JavaScript]]

В предыдущем уроке вы научились добавлять пользователя в базу данных. Теперь перейдём к аутентификации. В этом уроке реализуем базовый способ аутентификации — по адресу почты и паролю.

## Создаём контроллер аутентификации

Чтобы войти в систему, пользователь отправляет на сервер почту и пароль. Это удобно делать в теле запроса:

Скопировать кодJAVASCRIPT

```
// controllers/users.js

module.exports.login = (req, res) => {
  const { email, password } = req.body;

  // ...
}; 
```

Если почта и пароль совпадают с теми, что есть в базе, пользователь входит на сайт. Иначе — получает сообщение об ошибке. Проверить корректность данных можно по-разному:

- поискать пользователя с полученной почтой в базе. Если пользователь нашёлся, высчитать хеш пароля и сравнить его с хешем в базе;
- посчитать хеш пароля и проверить, есть ли в базе пользователь с полученной почтой и хешем пароля.

Мы будем пользоваться первым способом — он эффективнее. При втором подходе считать хеш пароля придётся в любом случае, даже если пользователя с указанной почтой не существует. А подсчёт хеша каждый раз занимает ресурсы процессора.

### Ищем пользователя

Проверим, есть ли пользователь в базе:

Скопировать кодJAVASCRIPT

```
// controllers/users.js

module.exports.login = (req, res) => {
  const { email, password } = req.body;

  User.findOne({ email })
    .then((user) => {
      if (!user) {
        // пользователь с такой почтой не найден
      }

      // пользователь найден
    });
}; 
```

Если пользователь не найден, перейдём в блок `catch` и вернём ответ с ошибкой:

Скопировать кодJAVASCRIPT

```
// controllers/users.js

module.exports.login = (req, res) => {
  const { email, password } = req.body;

  User.findOne({ email })
    .then((user) => {
      if (!user) {
        // пользователь не найден — отклоняем промис
        // с ошибкой и переходим в блок catch
        return Promise.reject(new Error('Неправильные почта или пароль'));
      }

      // пользователь найден
    })
    .catch((err) => {
      // возвращаем ошибку аутентификации
      res
        .status(401)
        .send({ message: err.message });
    });
}; 
```

### Проверяем пароль

Если пользователь найден, проверим пароль: захешируем его и сравним с хешем в базе. Для этого есть метод `bcrypt.compare`. Он принимает на вход пароль и его хеш. Метод посчитает хеш и сравнит его с тем хешем, который мы передали вторым аргументом:

Скопировать кодJAVASCRIPT

```
// controllers/users.js

module.exports.login = (req, res) => {
  const { email, password } = req.body;

  User.findOne({ email })
    .then((user) => {
      if (!user) {
        return Promise.reject(new Error('Неправильные почта или пароль'));
      }

      // сравниваем переданный пароль и хеш из базы
      return bcrypt.compare(password, user.password);
    })
    .catch((err) => {
      res
        .status(401)
        .send({ message: err.message });
    });
}; 
```

Метод `bcrypt.compare` работает асинхронно, поэтому результат нужно вернуть и обработать в следующем `then`. Если хеши совпали, в следующий `then` придёт `true`, иначе — `false`:

Скопировать кодJAVASCRIPT

```
// controllers/users.js

module.exports.login = (req, res) => {
  const { email, password } = req.body;

  User.findOne({ email })
    .then((user) => {
      if (!user) {
        return Promise.reject(new Error('Неправильные почта или пароль'));
      }

      return bcrypt.compare(password, user.password);
    })
    .then((matched) => {
      if (!matched) {
        // хеши не совпали — отклоняем промис
        return Promise.reject(new Error('Неправильные почта или пароль'));
      }

      // аутентификация успешна
      res.send({ message: 'Всё верно!' });
    })
    .catch((err) => {
      res
        .status(401)
        .send({ message: err.message });
    });
}; 
```

Мы намеренно сделали текст ошибки независимым от проблемы. Неважно, не найдена почта или неверно указан пароль — мы всегда передаём ответ «Неправильная почта или пароль». Иначе злоумышленник мог бы подобрать зарегистрированные почты и попытаться взломать именно их. В нашем случае мошенник не узнает, где допустил ошибку.