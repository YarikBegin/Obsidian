[[Объекты]]

И напоследок пара дополнительных уроков. Но прочитайте эти уроки внимательно: вам как будущему разработчику обязательно нужно понимать, что массивы и функции в JavaScript — тоже объекты. Об этом и будем говорить в уроках.

Мы упоминали вскользь, что массивы тоже объекты. Но объекты необычные.

Массив — это объект со специальными методами (например, `push` и `map`) и свойством `length`. Числовые индексы — это ключи, а соответствующие им элементы — значения этих ключей. Но мы можем записать в массив и нечисловой ключ как в обычный объект:

Скопировать кодJAVASCRIPT

```
const arr = [1, 2, 3];
arr.four = 4;

console.log(arr.four); // 4
console.log(arr); // [1, 2, 3, four: 4] — можно и весь arr вывести, так забавнее 
```

На практике такое поведение массивов используют крайне редко. Любой современный движок оптимизирует работу с массивами. Но если записывать в них нечисловые ключи, оптимизация может сломаться, и движок начнёт работать с массивом как с обычным объектом.

Как говорится, даже если томат — это фрукт, не стоит добавлять его в фруктовый салат. Вот и с массивом также: важно знать, что это объект, но не стоит давать ему нечисловых свойств.

## Проверка на массив

Если для JS нет разницы, с массивом он работает или с обычным объектом, то для разработчика эта разница может быть важна. Оператор `typeof` тут не поможет — для массива он тоже вернёт значение `object`:

Скопировать кодJAVASCRIPT

```
const arr = [1, 2, 3];

console.log(typeof arr); // "object" 
```

Раньше для такой проверки приходилось изрядно исхитриться. Благо в ES2015 появился удобный способ делать это — метод `Array.isArray`:

Скопировать кодJAVASCRIPT

```
const arr = [1, 2, 3];
const obj = {};

console.log(Array.isArray(arr)); // true
console.log(Array.isArray(obj)); // false 
```

Этот метод уже хорошо поддерживается современными браузерами, поэтому его можно использовать без опаски.

## Передача по ссылке

Поскольку массивы — это объекты, они передаются и сравниваются по ссылке.

Скопировать кодJAVASCRIPT

```
const a = [1, 2, 3];
const b = [1, 2, 3];
const c = b;

console.log(a === b); // false
console.log(b === c); // true 
```

## Копирование массива

Как объекты, массивы можно копировать методом `Object.assign`:

Скопировать кодJAVASCRIPT

```
const boringTale = [
    'У попа была собака, он её любил,',
    'Она съела кусок мяса, поп её убил,',
    'В землю закопал,',
    'И надпись написал о том, что'
];

const boringTale2 = Object.assign([], boringTale);

console.log(boringTale === boringTale2); // false. 
// Это два разных массива, но с одинаковым набором элементов. 
```

Более простой способ скопировать массив — вызвать метод `slice`, не передавая тому никаких аргументов:

Скопировать кодJAVASCRIPT

```
const boringTale = [
    'У попа была собака, он её любил,',
    'Она съела кусок мяса, поп её убил,',
    'В землю закопал,',
    'И надпись написал о том, что'
];

const boringTale2 = boringTale.slice();

boringTale === boringTale2; // false

/* Поскольку это два разных массива,
их сравнение возвращает false. При этом
все элементы в обоих массивах идентичны: */

boringTale[0] === boringTale2[0]; // true
boringTale[1] === boringTale2[1]; // true
boringTale[2] === boringTale2[2]; // true
boringTale[3] === boringTale2[3]; // true 
```

Вы уже пользовались массивами как объектами, не задумываясь об этом: когда обращались к свойству `length` или вызывали любой из методов массива.

В остальном нам редко бывает важно, что массив — это объект, так как не принято заносить в массив нечисловые свойства. Но даже редкие случаи иногда наступают.

Кроме того, чтобы стать разработчиком, важно не только уметь заставить код работать, но и понимать, как функционирует язык, какую структуру он имеет. И это критически важно для понимания концепции объектно-ориентированного программирования в JavaScript.