[[JavaScript]]

В предыдущей теме мы разбирали хранение JWT в localStorage. Это хороший способ, потому что с локальным хранилищем удобно работать.

Однако, у него есть большой недостаток — низкий уровень безопасности. Локальное хранилище доступно из JavaScript, поэтому при успешной XSS-атаке злоумышленник может украсть токен и совершать действия от лица пользователя.

Как бы хорошо ни был защищён сервер, он всё равно может быть подвержен XSS-атаке. Если на сайте много зависимостей, в одной из них может оказаться вредоносный код. Поэтому дополнительная защита токена не помешает.

## Куки

Данные в браузере можно сохранять в так называемые куки. Это фрагменты данных, относящихся к определённому домену.

Чтобы записать данные в куки браузера, сервер должен отправить заголовок `Set-Cookie`:

Скопировать кодJAVASCRIPT

```
res.set('Set-Cookie', 'name=Стас'); 
```

Получив такой заголовок, браузер сохранит `name=value` в куках.

Вручную устанавливать куки неудобно. Зато это удобно делать в express — тут для этого есть метод `res.cookie`:

Скопировать кодJAVASCRIPT

```
res.cookie('name', 'Стас'); 
```

Первый аргумент — это ключ, второй — значение.

Метод `res.cookie` особенно удобен для отправки опций, контролирующих поведение кук. К примеру, куки являются сессионными по умолчанию. То есть, когда пользователь закрывает страницу — они удаляются. Это поведение можно изменить, отправив опцию `maxAge`. Она хранит срок жизни куки:

Скопировать кодJAVASCRIPT

```
// такая кука будет храниться час
res.cookie('name', 'Стас', { maxAge: 3600000 });

// а такая 7 дней
res.cookie('name', 'Стас', { maxAge: 3600000 * 24 * 7 }); 
```

Также по умолчанию к кукам есть доступ из JavaScript. Но в отличие от localStorage, это можно изменить опцией `httpOnly`:

Скопировать кодJAVASCRIPT

```
res.cookie('name', 'Стас', {
  maxAge: 3600000,
  httpOnly: true
}); 
```

Такую куку нельзя прочесть из JavaScript. Защитим токен:

Скопировать кодJAVASCRIPT

```
// отправим токен, браузер сохранит его в куках

res
  .cookie('jwt', token, {
        // token - наш JWT токен, который мы отправляем
    maxAge: 3600000,
    httpOnly: true
  })
  .end(); // если у ответа нет тела, можно использовать метод end 
```

JWT сохранится в куках, к которым у JavaScript кода не будет доступа. А значит, токен не украсть при XSS-атаке.

## Говорим fetch отправлять куки

Мы сохранили данные в куках, у которых нет доступа из JS кода, но запросы мы посылаем из JavaScript, используя `fetch`. Как быть? Браузер автоматически пошлёт куки, если фронтенд и бэкенд работают на одном домене. То есть если express сервер отвечает и за API и за раздачу фронтенда, то куки будут отправлены.

Если фронтенд и бэкенд работают на разных доменах, например, фронтенд мы разместили на Github Pages, а бэкенд ещё где-то, то в fetch нужно включить опцию `credentials`:

Скопировать кодJAVASCRIPT

```
fetch('/posts', {
  method: 'GET',
  credentials: 'include', // теперь куки посылаются вместе с запросом
}); 
```

И браузер пошлёт куки в специальном заголовке `Cookie`.

## Разбираем сookie на сервере

С отправкой кук разобрались, переходим к их чтению на сервере. Для этого нужно извлечь данные из заголовка `Cookie` и затем разобрать полученную строку в объект. Это удобно сделать модулем `cookie-parser`. Установите его перед использованием и подключите как мидлвэр:

Скопировать кодJAVASCRIPT

```
const express = require('express');
const cookieParser = require('cookie-parser');

const app = express();

app.use(cookieParser()); // подключаем парсер кук как мидлвэр 
```

Теперь куки доступны в объекте `req.cookies`:

Скопировать кодJAVASCRIPT

```
const express = require('express');
const cookieParser = require('cookie-parser');

const app = express();

app.use(cookieParser());

app.get('/posts', (req, res) => {
  console.log(req.cookies.jwt); // достаём токен
}); 
```

## Проблемы такого подхода

Подход httpOnly не защищает токен от XSS полностью. Если злоумышленнику удастся внедрить JS-код на сайт, он сможет отправить авторизованный запрос к серверу — так же как его отправляем мы. Но важно, что злоумышленник не сможет прочитать информацию, которая хранится в httpOnly-куке: он не сможет загрузить её к себе на сервер и проанализировать.

Коротко о проблеме, которая появилась, как только мы начали использовать куки.

Теперь наше приложение подвержено CSRF-атаке. В следующем уроке будем защищаться от неё.

## Ссылки

Документация метода res.cookie:

[https://expressjs.com/ru/api.html#res.cookie](https://expressjs.com/ru/api.html#res.cookie)

Документация модуля cookie-parser

[https://github.com/expressjs/cookie-parser](https://github.com/expressjs/cookie-parser)