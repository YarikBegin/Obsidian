[[Продвинутый JavaScript]]

Чтобы пользователю не приходилось при каждом посещении сайта вводить пароль, нужно верифицировать его данные. Один из способов — проверить наличие валидного JWT-токена на стороне пользователя. В этом уроке напишем фронтенд для сохранения токена в браузере.

## Два браузерных хранилища

В зависимости от цели токен хранят в одном из двух браузерных хранилищ:

1.  **Session storage** (с англ. сессионное хранилище). Данные отсюда удаляются в конце сессии, то есть когда пользователь закрывает окно браузера.
    
    Сессионное хранилище можно сравнить с оперативной памятью: при выключении компьютера все несохранённые документы пропадут, потому что удалятся из оперативной памяти.
    
2.  **Local storage** (с англ. локальное хранилище). Данные хранятся в нём до тех пор, пока их не удалят вручную.
    
    Локальное хранилище работает как постоянная память: после перезагрузки компьютера все документы на жёстком диске остаются в сохранности.
    

Оба хранилища принадлежат домену. То есть к данным невозможно обратиться из хранилища yandex.ru, если вы находитесь на google.com.

В приложении Криптоутки будем пользоваться локальным хранилищем, ведь мы не хотим заставлять пользователей вводить логин и пароль при каждом посещении сайта.

Данные в local storage хранятся как JS-объекты, которые доступны глобально. У каждого объекта есть встроенные методы. Вот самые важные:

-   `setItem` для сохранения данных,
-   `getItem` для получения сохранённых данных,
-   `removeItem` для удаления данных из памяти.

Скопировать кодJSX

```
// сохраняем username
localStorage.setItem('username', 'Стас Басов');

// получаем username
localStorage.getItem('username'); // "Стас Басов"

// удаляем username
localStorage.removeItem('username');

// если ключа нет, вернётся null
localStorage.getItem('username'); // null 
```

`setItem` принимает два аргумента: ключ и его значение. Значением может быть только строка. Потому метод `setItem` приведёт любой аргумент к строке.

Для перевода объекта в строку пользуйтесь методом `JSON.stringify`. Если просто передать методу `setItem` объект, он будет приведён к строке встроенным методом `toString`, результатом работы которого будет `[Object object]` для любого объекта.

Метод `JSON.stringify` работает иначе: он создаст строку из объекта ровно в том виде, в каком он оформлен.

Чтобы превратить JSON-строку обратно в объект, вызовите метод `JSON.parse`:

Скопировать кодJSX

```
// сохраняем username
localStorage.setItem('user', JSON.stringify({
  firstName: 'Стас',
  lastName: 'Басов'
}));

// достаём username
JSON.parse(localStorage.getItem('user'));

//  {
//    firstName: 'Стас',
//    lastName: 'Басов'
//  } 
```

## Сохраняем токен

Напишем код для сохранения токена в локальном хранилище. Напомним, что мы выбрали localStorage, чтобы пользователю не нужно было повторно логиниться после закрытия браузера:

Скопировать кодJSX

```
// отправляем запрос на роут аутентификации
fetсh('https://api.mywebsite.com/signin', {
  method: 'POST',
  body: JSON.stringify({
    email: 'stasbasov@yandex.ru',
    password: 'StasBasov1989'
  })
})
.then(res => res.json())
.then((data) => {
  // сохраняем токен
  localStorage.setItem('token', data.token);
}); 
```

Теперь токен сохранён в локальном хранилище. Осталось настроить его отправку на сервер.

## Отправляем токен в запросах

Сделаем запросы авторизованными. Для этого внутри запроса нужно отправлять токен — по нему сервер понимает, есть ли у клиента права на выполнение действия.

Токен отправляют в заголовке `authorization`. Кроме самого токена заголовок должен содержать схему аутентификации — она сообщает серверу, что проверять наличие прав у пользователя нужно по токену. Имя такой схемы — `Bearer`. Есть и другие, но не будем в них углубляться.

В заголовок `authorization` нужно записать через пробел схему аутентификации и токен:

Скопировать кодJSX

```
// отправляем запрос на роут аутентификации
fetch('https://api.mywebsite.com/posts', {
  method: 'GET',
  headers: {
    authorization: `Bearer ${localStorage.getItem('token')}`
  }
}); 
```

Готово! В следующем уроке научимся реализовывать вход в систему.