[[Обработка событий]]

На веб-странице бывает много обработчиков событий. Так в плейлисте из тысячи песен может быть по одному обработчику лайка на каждую:

Скопировать кодJAVASCRIPT

```
// выберем все кнопки лайка
const songLikes = document.querySelectorAll('.song__like');

// пройдём по ним
songLikes.forEach((songLike) => {
  // добавим каждой обработчик лайка
  songLike.addEventListener('click', function (evt) {
    like(evt.target);
  });
}); 
```

У каждого элемента свой обработчик, хотя логика постановки лайка одинакова. И каждый такой обработчик — отдельная функция, которая занимает память браузера.

Но можно сделать процесс проще и эффективнее. Для этого используют два механизма браузера — всплытие и делегирование событий. О них и пойдёт речь в уроке.

Представьте, что вы — начинающий тиктокер и захотели купить попит (ну вдруг). Доставку попита пришлось бы ждать долго, так что вы решили написать собственный сайт с попитом, где пользователи могут нажимать на него и тем самым снимать стресс. Продавливание отверстий попита — это действие (громко сказано, но ничего страшного), другими словами — наше событие click в JS.

Начинающий тиктокер повесил бы слушатель событий `click` на каждый элемент попита. А продвинутый тиктокер повесил бы слушатель `click` на сам попит, потому что знает, что событие `click` всплывает. Подход, в котором слушатель события добавляется не на сам элемент (а их может быть тысячи), а на ближайшего общего для множества элементов родителя называется делегированием.

О том, как стать продвинутым тиктокером (но только в JS, так что не спешите сбегать), и пойдёт речь в этом уроке. Вы узнаете про фазу всплытия событий и паттерн их делегирования.

## Всплытие событий

Если событие происходит на элементе, оно срабатывает ещё и на каждом элементе-родителе. Такой механизм называется «всплытие»:

Скопировать кодHTML

```
<!-- index.html -->

<div id="parent">
  <div id="firstChild">
    <div id="secondChild">
      <div id="thirdChild">Нажми и всё поймёшь</div>
    </div>
  </div>
</div> 
```

Скопировать кодJAVASCRIPT

```
/* script.js */

const parent = document.querySelector('#parent');
const firstChild = document.querySelector('#firstChild');
const secondChild = document.querySelector('#secondChild');
const thirdChild = document.querySelector('#thirdChild');

function callback(evt) {
  console.log('Событие обработано');
};

parent.addEventListener('click', callback);
firstChild.addEventListener('click', callback);
secondChild.addEventListener('click', callback);
thirdChild.addEventListener('click', callback); 
```

Если кликнуть на элемент `thirdChild`, текст «Событие обработано» появится в консоли 4 раза. Так происходит, потому что вначале событие происходит на самом элементе, а потом на всех его родителях по очереди. Поэтому обработчики клика элементов `secondChild`, `firstChild` и `parent` тоже сработают.

И это не всё. Кроме тех блоков, на которые мы повесили обработчики, событие сработает и на `body`, `html`, `document` и `window`.

Так событие на блоке `thirdChild` перешло к элементу `secondChild`, сработало на нём — и пошло дальше вплоть до `window`.

Принцип домино в действии.

## Делегирование событий

То, что события всплывают, даёт нам мощный инструмент для их обработки — делегирование. Вернёмся к примеру с плейлистом, в котором тысяча песен. Как мы поняли в начале урока, им понадобится 1000 обработчиков лайка.

К тому же песни могут удаляться и добавляться. При загрузке новой песни в плейлист ей тоже нужно добавить обработчик. Можно только и заниматься тем, что добавлять элементам обработчики. С небольшими промежутками на еду и сон.

Но из этой ситуации есть спасение — делегирование. Поскольку события всплывают, неважно, где вы добавите обработчик. Клик всё равно сработает на каждом элементе — от самого глубокого, на который вы и нажали, до глобального объекта `window`.

Поэтому можно добавить обработчик не самой кнопке лайка, а всему плейлисту:

Скопировать кодJAVASCRIPT

```
const playlist = document.querySelector('.playlist');

// добавим обработчик лайка отдельной песни всему плейлисту
playlist.addEventListener('click', function (evt) {
  // осталось разобраться, какой код в нём написать
}); 
```

Поэтому делегировать событие — это переносить обработчик на родительский элемент, но при этом отслеживать дочерний.

Свойство `evt.target` никак не зависит от того, куда вы повесили обработчик. Куда бы вы ни нажали, в `evt.target` попадёт самый глубокий элемент DOM-дерева из всех, где сработало событие.

Если пользователь ставит лайк, кнопка сердечка будет в `evt.target`, даже если обработчик находится на родителе:

Скопировать кодJAVASCRIPT

```
const playlist = document.querySelector('.playlist');

// добавим всему плейлисту обработчик лайка отдельной песни 
playlist.addEventListener('click', function (evt) {
  like(evt.target); // если нажали на «Лайк», то он в evt.target
}); 
```

Но обработчик сработает, даже если вместо лайка кликнуть на название песни. Тогда в свойство `evt.target` попадёт уже не кнопка лайка, а элемент с названием.

В этом случае лайк ставить не нужно. Для этого в обработчик добавляют условную конструкцию:

Скопировать кодJAVASCRIPT

```
playlist.addEventListener('click', function (evt) {
  // если нажали на «Лайк», поставь лайк
  if (evt.target.classList.contains('song__like')) {
    like(evt.target);
  }

  // иначе ничего делать не нужно
}); 
```

К этому обычно и сводится механизм делегирования. Обработчик обрабатывает каждое событие на элементе, а условная конструкция проверяет, на каком из дочерних оно произошло.

## Свойство `evt.currentTarget`

Свойству `evt.target` неважно, где висит обработчик: в него всегда записывается самый нижний элемент DOM, на котором это событие сработало. Элемент, на котором висит обработчик, хранится в свойстве `evt.currentTarget`:

![image](https://pictures.s3.yandex.net/resources/delegirovanie_1588446831.gif)

_На гифки в этой теме можно смотреть бесконечно_

Какое свойство что хранит:

-   `evt.currentTarget` — элемент, где сработал обработчик;
-   `evt.target` — элемент, где возникло событие.