[[JavaScript]]

Для чтения запроса можно использовать поток (англ. stream) — вы уже делали это в четвёртом уроке темы. Но это не единственное назначение потоков: они используются в Node.js, в том числе для работы с файлами. Поток — последовательность данных, которые поступают от какого-то источника. Файл вполне может быть таким источником.

![image](https://pictures.s3.yandex.net/resources/node-14_1568027633.png)

### Какие бывают потоки и как ими пользоваться?

Потоки бывают трёх видов:

- для чтения данных из тела запроса или из файла;
- для записи данных в файл;
- дуплексные потоки — одновременно для чтения и записи.

Дуплексные потоки часто используют для трансформации данных, которые в них поступают. Их можно комбинировать с потоками чтения и записи.

К примеру, на сайте есть видео с разрешением 1920 на 1080 точек. Пользователь подключается к общественному вайфаю в аэропорту и пытается его посмотреть. Скорость оставляет желать лучшего, и видео тормозит. Тут на помощь вам, вайфаю и пользователю приходят потоки:

- сначала открывается поток чтения из видеофайла;
- данные попадают в дуплексный поток: он одновременно считывает данные и преобразует их — сжимает;
- затем данные попадают в поток для записи — на устройство пользователя.

В результате видео хоть и потеряло в качестве, зато не тормозит.

### Как работать с потоками?

В модуле `fs` есть методы `createReadStream` и `createWriteStream`. Они создают потоки для чтения и записи соответственно. Первым аргументом методы принимают путь к файлу, а вторым — объект опций, где можно передать, например, кодировку:

Скопировать кодJAVASCRIPT

```
const fs = require('fs');

// создаём поток для чтения из файла in.txt
const reader = fs.createReadStream('./in.txt', { encoding: 'utf8' });

// создаём поток для записи в файл out.txt
const writer = fs.createWriteStream('./out.txt', { encoding: 'utf8' }); 
```

Чтобы скомбинировать потоки чтения и записи, то есть превратить их в дуплексный поток, нужно при каждом событии `data` потока чтения вносить порцию данных в поток записи:

Скопировать кодJAVASCRIPT

```
const fs = require('fs');

const reader = fs.createReadStream('./in.txt', { encoding: 'utf8' });
const writer = fs.createWriteStream('./out.txt', { encoding: 'utf8' });

reader.on('data', (data) => { // отслеживаем событие data потока чтения
  writer.write(data); // записываем порцию данных в поток записи
}); 
```

Когда данные полностью прочитаны, поток для чтения сгенерирует событие `end`. Его нужно обработать и сообщить потоку записи, что все данные пришли и ничего больше записывать не нужно. Для этого у потока записи есть метод `end`:

Скопировать кодJAVASCRIPT

```
const fs = require('fs');

const reader = fs.createReadStream('./in.txt', { encoding: 'utf8' });
const writer = fs.createWriteStream('./out.txt', { encoding: 'utf8' });

reader.on('data', (data) => {
  writer.write(data);
});

// когда все данные прочитаны, даём Node сигнал,
// что поток для записи больше нам не нужен
reader.on('end', () => {
  writer.end();
}); 
```

Последнее, что нужно сделать — обработать ошибку. В случае ошибки поток для чтения сгенерирует событие `error`. Его нужно обработать:

Скопировать кодJAVASCRIPT

```
const fs = require('fs');

const reader = fs.createReadStream('./in.txt', { encoding: 'utf8' });
const writer = fs.createWriteStream('./out.txt', { encoding: 'utf8' });

reader.on('data', (data) => {
  writer.write(data);
});

reader.on('end', (data) => {
  writer.end();
});

// повесим обработчик события error
reader.on('error', (err) => {
  console.log(err);
}); 
```

### Почему не воспользоваться методами чтения и записи файлов?

Конечно, эту логику можно реализовать методами `readFile` и `writeFile`. Но при таком подходе программа работала бы медленнее, потому что серверу пришлось бы сначала полностью прочитать файл, записать его в оперативную память и только потом — на диск. Получается, для обработки каждого файла нужно заметно больше памяти. Причём больше на размер файла. Если вы загружаете видео, программа в целом будет работать ещё медленнее.

Потоки позволяют избежать таких проблем: данные читаются небольшими порциями и тут же записываются на диск. В оперативке при этом сохраняется только очередная порция данных, и алгоритм менее «прожорливо» потребляет память.

### Метод pipe для работы с потоками

Чтобы организовать простейшую работу с двумя потоками, мы добавили три обработчика событий. Но код можно сделать заметно короче, если воспользоваться специальным методом для комбинирования потоков — `pipe`. Вам даже не нужно закрывать потоки и обрабатывать ошибки — вся эта логика уже описана внутри метода `pipe`:

Скопировать кодJAVASCRIPT

```
const fs = require('fs');

const reader = fs.createReadStream('./in.txt', { encoding: 'utf8' });
const writer = fs.createWriteStream('./out.txt', { encoding: 'utf8' });

reader.pipe(writer); 
```

Метод `pipe` есть только у потоков для чтения — поток для записи передают как аргумент.

Напоследок разберём простой пример. Обращение пользователя к серверу — тоже поток для чтения, так что мы можем обработать этот запрос методом `pipe`:

Скопировать кодJAVASCRIPT

```
const http = require('http');
const fs = require('fs');

const server = http.createServer(function (req, res) {
  req.pipe(fs.createWriteStream(`./out-${Math.random()}.txt`));
});

server.listen(3000); 
```

Данные, которые пользователь отправил в запросе, мы записываем этим кодом в текстовый файл со случайным именем.

Потоки — большая и сложная тема. Мы рассказали лишь об основах, которые необходимы на практике. Тем не менее, если вы хотите освоить «серьёзный» бэкенд, в потоках нужно основательно разобраться.