[[JavaScript]]

Один из самых распространённых вопросов на собеседовании на должность JavaScript-разработчика: «Что такое замыкание?».

![image](https://pictures.s3.yandex.net/resources/User_ID___1__7_1598194384.jpg)

О замыкании ходят легенды, а понимание замыканий сравнивают с прозрением. В этом уроке мы попытаемся обрести это прозрение. На самом деле вы уже много раз пользовались замыканиями, просто не знали об этом.

## Вспомним про область видимости

Мы уже про неё рассказывали. Напомним: если обратиться к идентификатору внутри функции, движок сначала будет искать его внутри этой функции. Если не найдёт, пойдёт искать снаружи. При этом если одна область видимости вложена в другую, движок будет переходить от самой вложенной до глобальной, как по ступенькам.

Скопировать кодJAVASCRIPT

```
const a = 1;

function callMe() {
  const b = 2;

  function callMeToo() {
    console.log(a); // a найдётся в глобальной области
    console.log(b); // b найдётся в области видимости функции callMe
  }

  callMeToo();
}

callMe();

/* В консоль выведется:

    1
    2

*/ 
```

Движок руководствуется правилом: «Если переменной нет внутри, поищу снаружи».

## Функцию можно вызвать не там, где она была создана

Раньше вы могли вызвать функцию только в той же области видимости, в какой она объявлена, или «более внутренней»:

Скопировать кодJAVASCRIPT

```
function abc() {
    console.log('Hello');

    function xyz() {
    /* Это область видимости функции xyz.
    Отсюда мы можем обратиться к функции abc. */

        abc();
    }

  /* Это область видимости функции abc.
  Отсюда можем обратиться к xyz —
  она в области видимости функции abc. */

    xyz();
}

/* А дальше будет ошибка — в глобальной
области видимости нет функции с именем xyz. */

xyz(); 
```

Но на самом деле функцию можно вызвать и из другой области видимости. Вот как это делается.

Функция может вернуть другую функцию:

Скопировать кодJAVASCRIPT

```
function callMe() {
  const internet = 'Internet';

  function callMeToo() {
    console.log(internet);
  }

  return callMeToo;
} 
```

Теперь если вызвать callMe и записать её результат в переменную, получим функцию callMeToo во внешней области видимости.

Скопировать кодJAVASCRIPT

```
function callMe() {
  const internet = 'Internet';

  function callMeToo() {
    console.log(internet);
  }

  return callMeToo;
}

const newCallMeToo = callMe();
console.log(newCallMeToo);

/*
    ƒ callMeToo() {
        console.log(internet);
    }
*/ 
```

Теперь у нас есть функция callMeToo в глобальной области видимости — она записана в переменную newCallMeToo. Посмотрите на код этой функции: она обращается к переменной internet, объявленной внутри callMe.

Получается такая ситуация: мы получили функцию callMeToo во внешней области видимости. Эта функция обращается к переменной internet, которой в этой области видимости нет. Вызовем эту функцию и посмотрим, что будет:

Скопировать кодJAVASCRIPT

```
function callMe() {
  const internet = 'Internet';

  function callMeToo() {
    console.log(internet);
  }

  return callMeToo;
}

const newCallMeToo = callMe();

newCallMeToo(); // "Internet" 
```

У функции newCallMeToo всё равно есть доступ к переменной internet. И он у неё будет, даже если удалить функцию callMe вовсе:

Скопировать кодJAVASCRIPT

```
let callMe = function () {
  const internet = 'Internet';

  function callMeToo() {
    console.log(internet);
  }

  return callMeToo;
}

const newCallMeToo = callMe();

callMe = null; // убиваем функцию callMe, её больше нет

newCallMeToo(); // "Internet" 
```

Дело в том, что функция callMeToo запомнила свою область видимости, когда мы её объявили — то есть момент вызова callMe. И даже если вызвать её из другого места, она всё равно будет помнить, какие идентификаторы существовали с ней в одной области видимости при объявлении. Это и есть замыкание.

> Замыкание — это способность функции запоминать область видимости, в которой она была создана, и иметь доступ к ней даже при вызове вне этой области видимости.

Можно сравнить замыкание с портфелем, который собирает функция при объявлении, а затем берёт его с собой в любое место, где бы она ни была. Функция кладёт в этот портфель все переменные области видимости, в которой она была объявлена.

![image](https://pictures.s3.yandex.net/resources/JS3_2___1__3_1598194406.png)

## Замыкания изнутри

Что такое замыкание, разобрались. Теперь расскажем, как движок их создаёт.

Вы уже знаете об этом — вспомните прошлый урок этой темы. При создании функции у неё появляется внутреннее свойство [[Environment]]. Оно указывает на внешний LexicalEnvironment — объект переменных области видимости, в которой функция была создана. Здесь это объект переменных функции callMe.

![image](https://pictures.s3.yandex.net/resources/Untitled_1600875195.png)

Когда мы вернули callMeToo наружу, в свойстве [[Environment]] она унесла с собой объект переменных области видимости, в которой была объявлена.

Теперь откуда ни вызови функцию, при обращении к переменным движок сначала ищет их внутри самой функции, а затем во внешнем объекте переменных, находя его в свойстве [[Environment]]. Если в этом объекте есть нужная переменная (в нашем случае internet), говорят, что функция берёт её из замыкания.

![image](https://pictures.s3.yandex.net/resources/JS3_2___1__5_1598194467.png)

Если бы переменной internet не было в свойстве [[Environment]] функции `callMeToo`, движок стал бы искать её в глобальной области видимости, заглянув в свойство [[Environment]] функции callMe. Если бы нашёл её там, мы всё равно сказали бы, что переменная взята из замыкания.

## Важно

Замыкание создаётся тогда же, когда и внешний объект LexicalEnvironment. То есть, при вызове функции.

Скопировать кодJAVASCRIPT

```
function callMe() {
  const internet = 'Internet';

  function callMeToo() {
    console.log(internet);
  }

  return callMeToo;
}

const newCallMeToo = callMe(); // здесь создаётся замыкание функции callMeToo

newCallMeToo(); // "Internet" 
```

Пока функция callMe не вызвана, код внутри неё движком не выполняется. Соответственно и callMeToo не объявляется, и замыкание не создаётся.

## Резюме

Тема замыканий не проста. Поэтому не переживайте, если не вникли сразу. Мы и сами поняли её не с первого раза.

В следующем уроке расскажем, чем замыкания полезны на практике. Это тоже поможет понять их суть.