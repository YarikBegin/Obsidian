[[JavaScript]]

Хорошие новости: мы закончили со спецсимволами и флагами. Осталось изучить несколько удобных методов. Вы уже знакомы с методом `String.match`. В этом уроке расскажем ещё о четырёх.

## Метод `String.search`

Метод `String.search` принимает на вход регулярное выражение и возвращает индекс символа, на котором произошло совпадение:

Скопировать кодJAVASCRIPT

```
const regex = /\d{3,}/i;
const string = '12! равен 479001600';

string.search(regex); // 10 
```

Метод `String.search` не работает с глобальным поиском — он всегда возвращает индекс первого совпадения:

Скопировать кодJAVASCRIPT

```
const regex = /\d/ig;
const string = '12! равен 479001600';

string.search(regex); // 0 - индекс первого совпадения, то есть "1". 
```

Если же совпадения не было вовсе — нам вернётся `-1`:

Скопировать кодJAVASCRIPT

```
const regex = /[тут]$/i;
const string = "Тут царь мимо не проходил?";

string.search(regex); // -1 
```

## Метод `String.split`

Метод `String.split` вы уже встречали в теме о примитивах. Им мы создавали из строки массив:

Скопировать кодJAVASCRIPT

```
'Пришёл. Увидел. Победил.'.split(' '); // ["Пришёл.", "Увидел.", "Победил."]
'Пришёл. Увидел. Победил.'.split('. '); // ["Пришёл", "Увидел", "Победил."] 
```

Тут мы указываем разделитель как строку. Методу `String.split` можно передать на вход и регулярное выражение. Тогда на выходе мы получим массив элементов, которые находили между строчками, найденными нашей регуляркой:

Скопировать кодJAVASCRIPT

```
const regex = /\n/im;

`Мой дядя самых честных правил,
Когда не в шутку занемог,
Он уважать себя заставил
И лучше выдумать не мог.`.split(regex);

/* [
    "Мой дядя самых честных правил,",
    "Когда не в шутку занемог,",
    "Он уважать себя заставил",
    "И лучше выдумать не мог."
] */ 
```

Обратите внимание: метод `String.split` ожидает, что какой-то элемент должен быть и до, и после разделителя. Поэтому если ваша строка начинается с разделителя или заканчивается разделителем, в полученном массиве первым или последним элементом будет пустая строка.

## Метод `RegExp.exec`

Метод `RegExp.exec` похож на `String.match`. Если в регулярном выражении нет флага `g`, `String.match` и `RegExp.exec` вернут одинаковый результат:

Скопировать кодJAVASCRIPT

```
let regex = /\w+/;
let str = 'Someone must have been telling lies about Josef K.';

str.match(regex); // ["Someone"]
regex.exec(str); // ["Someone"] 
```

Но если установить флаг `g`, метод `RegExp.exec` будет вести себя совсем иначе. Он вернёт первое совпадение, а затем — запишет в свойство `lastIndex` регулярного выражения номер символа в тексте, на котором это совпадение произошло.

Если запустить метод `RegExp.exec` снова, он будет искать не с начала строки, а с того символа, на котором остановился в прошлый раз. То есть с записанного в свойство `lastIndex`:

Скопировать кодJAVASCRIPT

```
const str = `Идёт без проволочек
И тает ночь, пока
Над спящим миром лётчик
Уходит в облака.`;
let regex = /.+/g;

regex.exec(str); // ["Идёт без проволочек"]
regex.exec(str); // ["И тает ночь, пока"]
regex.exec(str); // ["Над спящим миром лётчик"]
regex.exec(str); // ["Уходит в облака."] 
```

`RegExp.exec` обновляет свойство `lastIndex` после каждого вызова.

Таким образом, метод `RegExp.exec` помнит, где закончил поиски в прошлый раз. Если запустить этот метод в цикле, мы можем точно контролировать, сколько совпадений хотим найти.

Если очередной поиск не дал результатов, в свойство `lastIndex` регулярного выражения записывается 0. То есть новый поиск начнётся с начала.

## Метод `RegExp.test`

Мы уже упоминали о методе `RegExp.test`. Он вызывается на регулярном выражении, а строку принимает на вход. Результат работы метода — булево значение. Если совпадение найти удалось, `RegExp.test` вернёт `true`:

Скопировать кодJAVASCRIPT

```
const regex = /\w+@\w+\.\w+/; // шаблон для поиска email
const str = 'Stas Basov: stasbasov@yandex.ru';

regex.test(str); // true 
```

Если же совпадений с регулярным выражением в строке нет, получим `false`:

Скопировать кодJAVASCRIPT

```
const regex = /\w+@\w+\.\w+/;
const str = 'Stas Basov';

regex.test(str); // false - в строке нет email. 
```

Метод `RegExp.test` тоже обладает памятью — как и `RegExp.exec`. Если передать ему регулярное выражение с флагом `g`, в свойство `lastIndex` этого регулярного выражения попадёт номер символа, где было найдено совпадение. И следующий поиск регулярного выражения начнётся с этого символа, а не с начала строки:

Скопировать кодJAVASCRIPT

```
const regex = /\w+@\w+\.\w+/g;
const str = 'Stas Basov: stas-basov@yandex.ru';

regex.test(str); // true
regex.lastIndex; // 32

// Вызовем метод RegExp.test ещё раз:
regex.test(str); // false
regex.lastIndex; // 0

/* предыдущий поиск не дал результатов,
поэтому свойство lastIndex было сброшено до нуля */ 
```

## Метод `String.replace`

И, наконец, последний метод — `String.replace`. Он позволяет на ходу собирать новый текст из исходного. Работает он так: ищет в тексте совпадение с регуляркой, составляет какую-то новую строку из полученной и возвращает её нам.

Всего у метода два параметра. Первый — это шаблон регулярного выражения. Вторым аргументом может быть строка или функция. Именно второй параметр определяет, как именно будет составлена новая строка из совпадения.

![image](https://pictures.s3.yandex.net/resources/sprint_10___1__234_1616957809.png)

Чаще всего методу `String.replace` передают строку. Все совпадения в исходном тексте будут заменены этой строкой.

Скопировать кодJAVASCRIPT

```
const strObj = 'Пробел всегда нужно ставить после запятой ,а не до неё.';
const regex = /\s,/g;

strObj.replace(regex, ', '); // "Пробел всегда нужно ставить после запятой, а не до неё." 
```

В этой строке можно использовать спецсимволы. Тогда движок не будет просто заменять совпадения какой-то строкой. Спецсимволы применяются редко, поэтому мы не будем разбирать их в этой теме.