
[[Модули в JS. Введение]]

Если тег `<script>` подключать с атрибутом `type="module"`, стандартное восприятие браузером JS немного изменится. Тут мы расскажем, что меняется для разработчика при использовании модульного подхода.

## Область видимости

У модуля своя область видимости. Он содержит локальные переменные и функции, которые не загрязняют глобальную область. Но если они нужны где-то снаружи, их придётся экспортировать:

Скопировать кодJAVASCRIPT

```
// constants.js

export const numbers = [2, 3, 5]; 
```

Скопировать кодJAVASCRIPT

```
// index.js

import { numbers } from './constants.js';

const doubledNumbers = numbers.map(number => number * 2);

console.log(doubledNumbers); // [4, 6, 10] 
```

Скопировать кодHTML

```
<!-- index.html -->

<script type="module" src="index.js"></script>
<script type="module" src="constants.js"></script>

<script>
  console.log(numbers); // ошибка — такой переменной в глобальной области нет
  console.log(doubledNumbers); // и такой тоже нет
</script> 
```

## Старые браузеры

В старых браузерах атрибута `type="module"` не существует. Поэтому если открыть сайт в браузере, который не поддерживает модули, JavaScript вообще не будет подключён.

Это можно обойти так: пишут отдельный код для старых браузеров и подключают отдельно. То есть дописывают ещё один тег `<script>`, а в его атрибут `type` записывают значение `"nomodule"`.

Скопировать кодHTML

```
<!-- этот модуль загрузится, если браузер современный -->
<script type="module"></script>
<!-- этот модуль загрузится, если браузер старый -->
<script type="nomodule"></script> 
```

Но так поступают редко. В следующем спринте мы расскажем о более продвинутых инструментах работы с модулями. Они в том числе сделают код понятным и старым браузерам.

## Модули — в конце

Модули всегда подключаются к странице после отрисовки. Поэтому неважно, где вы их подключаете — в начале или в конце файла:

Скопировать кодHTML

```
<script>
  console.log(document.querySelector('input')); // null

  /* без модулей такое не сработает, потому что поле ввода
  объявлено в коде ниже, а значит, мы пока не можем работать с ним */
</script>

<script type="module">
  console.log(document.querySelector('input')); // <input> 

  /* при модульном подходе таких проблем нет */
</script>

<input type="text"> 
```

Но мы всегда подключаем скрипты в конце `body`, поэтому вы вряд ли столкнётесь с такой проблемой.