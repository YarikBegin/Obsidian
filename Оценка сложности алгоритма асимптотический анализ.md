[[JavaScript]]

Для производительных программ важно подбирать эффективный алгоритм. Но что он должен делать, чтобы мы могли оценить его эффективность: вставать в 5:30, готовить себе на завтрак свежепророщенную зелёную гречку и отправляться бежать полумарафон с подкастом «Запуск завтра» в эйрподсах? Не совсем. Давайте разбираться вместе.

По двум параметрам:

- время выполнения (временна́я сложность алгоритма);
- расход памяти (пространственная сложность алгоритмов).

Чем дольше работает алгоритм и больше памяти потребляет, тем он хуже. Но параметры алгоритма зависят от устройства, на котором он выполняется, и количества входных данных, поэтому неверно утверждать, что «алгоритм работает 1 секунду и задействует 1 мегабайт памяти». Один и тот же алгоритм может работать на старом компьютере 10 секунд, а на современном — 1 секунду.

Из-за таких погрешностей применяют другой метод оценки производительности алгоритма — асимптотический анализ. Он не зависит от устройства, но учитывает размер данных, которые загрузили в программу на вход.

Когда говорят «сложность алгоритма», обычно имеют в виду временнýю сложность. На её примере рассмотрим, как работает асимптотический анализ.

Возьмём простую функцию и рассчитаем временную сложность:

Скопировать кодJAVASCRIPT

```
function sum(numbers) {
    let sum = 0;

  for (let i = 0; i < numbers.length; i += 1) {
        sum += numbers[i]
  }

  return sum;
} 
```

Она оценивает время работы программы. Чем больше операций нужно выполнить — тем дольше программа будет работать.

Выпишем все операции в функции `sum` и посчитаем их общее число:

- `let sum = 0` — создание переменной,
- `let i = 0` — создание переменной,
- `i < numbers.length` — проверка условия,
- `i += 1` — увеличение переменной на единицу,
- `numbers[i]` — доступ к элементу массива,
- `sum += numbers[i]` — увеличение переменной `sum`.

Последние четыре операции находятся в цикле и выполняются конкретное число раз — `numbers.length`. Посчитаем сумму всех операций. 4 операции в цикле нужно умножить на количество итераций цикла (`numbers.length`) и прибавить 2 первые операции в функции: `2 + 4 * numbers.length`. При длине массива `n` получаем выражение `2 + 4n`.

А так изменяется выражение при разных значениях `n`:

|n|2 + 4n|Δ|
|---|---|---|
|1|6||
|10|42|7|
|100|402|9.5714|
|1000|4002|9.9552|
|10000|40002|9.9955|
|100000|400002|9.9995|
|1000000|4000002|9.9999|

В первом столбце таблицы записаны разные значения `n`. Во втором –– как меняется количество операций в абсолютном выражении. А в третьем столбце указано, как меняется количество операций в относительном выражении по отношению к предыдущему значению.

При изменении `n` в 10 раз, изменение функции `2+4n` также стремится к 10. Например, при `n=10`, `2+4n=42`, а при `n=100`, `2+4n=402`. В относительном выражении –– `402 / 42 = 9.571`. Темп роста функции `2+4n` очень близок к функции `n`, особенно на больших значениях. Так происходит потому, что основной вклад в рост функции вносит самый значимый её член. Здесь это `n`.

С помощью асимптотического анализа мы оцениваем, как сложность алгоритма растёт с ростом входных данных. Важен только характер изменения функции, поэтому мы опускаем все константные коэффициенты и члены, кроме значимого.

Функция `2+4n` даёт сложность `О(n)`. Читается как «О большое от n». Записать можно так: `2 + 4n = О(n)`, или `О(2 + 4n)= О(n)`. Значит, что эта функция растёт не быстрее, чем функция `n`, умноженная на константу. Что правда, ведь обе функции линейные.

Здесь мы применили методику асимптотического анализа. Результат записали с помощью О-нотации.

Чтобы потренироваться находить О большое, рассмотрим ещё три выражения. Вы можете самостоятельно определить характер их роста, подставив разные значения `n`.

`10` можно представить как `10*n^0`. Сложность не меняется от размера входных данных, поэтому она будет `О(n^0)` или `О(1)`.

Функция `n^2` растёт быстрее, чем `n`, поэтому `n^2` — самый значимый член. Сложность равна `O(n^2)`.

Какая сложность функции `10n+50`?

Неправильный ответ

`О(10n)`

Нет. Нужно определить самый значимый член в функции и опустить коэффициент. Это и есть сложность.

Тоже правильный ответ

`О(n)`

Верно. `10n+50=O(n)`.

`О(n^2)`

`О(50)`

Какая сложность функции `n + n^2 / 1000`?

`О(log(n))`

Неправильный ответ

`О(n)`

Нет. Нужно найти в функции самый значимый член, который растёт быстрее остальных.

Тоже правильный ответ

`О(n^2)`

Верно. `n^2` растёт быстрее, чем `n`.

`О(n*log(n))`

Какая сложность функции `2^n + n^3`?

Тоже правильный ответ

`О(2^n)`

Верно. C ростом `n` `2^n` растёт быстрее, чем `n^3`.

`О(n)`

Неправильный ответ

`О(n^3)`

Нет. Нужно определить самый значимый член в функции. Это `2^n`, так как с ростом `n` `2^n` растём быстрее, чем `n^3`.

`О(1^n)`

Ещё раз запишем функцию `sum` и посчитаем пространственную сложность:

Скопировать кодJAVASCRIPT

```
function sum(numbers) {
    let sum = 0;

  for (let i = 0; i < numbers.length; i += 1) {
        sum += numbers[i]
  }

  return sum;
} 
```

Пространственная сложность оценивает объём памяти, который занимает алгоритм. Считать его в мегабайтах не нужно, просто оценим, как изменяется количество хранимой информации с изменением входных данных.

Посчитаем все переменные, созданные в функции `sum`:

- `let sum = 0` –– переменная для хранения суммы;
- `let i = 0` –– переменная для хранения индекса.

Мы создали всего две переменные. Пространственная сложность этого алгоритма –– `О(1)`. Она не зависит от входных данных –– массив любой длины будет расходовать одинаковый объём памяти.

В этом уроке при анализе сложности мы подсчитывали операции внутри функции `sum`. Но иногда за одной операцией скрывается гораздо больше. В следующем уроке научимся выявлять и анализировать такие операции.