[[Продвинутый JavaScript]]

Вы уже знаете, что от сервера приходит объект ответа. Чтобы получить из него данные, нужно вызвать встроенный метод `json`:

Скопировать кодJAVASCRIPT

```
fetch('https://api.kanye.rest')
  .then(res => res.json())
  .then((data) => {
    console.log(data);
  }); 
```

Но есть у объекта ответа также другие методы и свойства. О них сейчас и пойдёт речь.

## Статус

Наверняка с вами такое случалось: заходите на сайт, а вместо нужной страницы на экране большое число 404. Эти три цифры — код статуса ответа.

У ответа всегда есть статус — он может быть отклонён, перенаправлен или вернуться с ошибкой. Каждому статусу запроса соответствует уникальный код. 404 — один из таких кодов.

По коду статуса можно понять, что произошло с запросом. Если код начинается с:

-   2 — значит, запрос прошёл успешно;
-   3 — запрос был перенаправлен;
-   4 — с запросом что-то не так: ресурс не найден или у вас нет к нему доступа;
-   5 — на сервере произошла какая-то ошибка.

Вот самые распространённые статусы — с ними вы столкнётесь скорее всего:

-   200 OK;
-   401 Unauthorized;
-   403 Forbidden;
-   404 Not Found;
-   500 Internal Server Error.

После числа идёт сообщение статуса — оно объясняет, что произошло. Код и сообщения статуса хранятся в свойствах объекта ответа `status` и `statusText`:

Скопировать кодJAVASCRIPT

```
fetch('https://api.kanye.rest')
    .then(res => {
    console.log(res.status, res.statusText); // 200 OK
  }); 
```

Для удобства также доступно булево свойство `ok`. Оно хранит в себе `true`, если ответ успешный (начинается с 2), и `false` — в любом другом случае:

Скопировать кодJAVASCRIPT

```
fetch('https://api.kanye.rest')
    .then(res => {
    console.log(res.ok); // true
  }); 
```

По этому свойству можно определить, прошёл ли запрос успешно, и принять решение, что делать дальше:

Скопировать кодJAVASCRIPT

```
const quoteElement = document.querySelector('div.quote');

fetch('https://api.kanye.rest')
  .then((res) => {
    if (res.ok) {
      return res.json();
    }

    /* отклоняем промис, чтобы перейти
    в блок catch, если сервер вернул ошибку */
    return Promise.reject(`Что-то пошло не так: ${res.status}`);
  })
  .then((data) => {
    quoteElement.textContent = data.quote;
  })
  .catch((err) => {
    console.log(err); // "Что-то пошло не так: ..."
  }); 
```

## Заголовки ответа

Подобно запросам, ответы могут иметь заголовки. В них содержится дополнительная информация от сервера.

### Как получить данные из заголовков

Такой код выведет в консоль пустой объект, хотя ответ имеет заголовки:

Скопировать кодJAVASCRIPT

```
fetch('https://api.kanye.rest')
  .then((res) => {
    console.log(res.headers); // Headers {}
  }); 
```

Дело вот в чём. Заголовки нечувствительны к регистру, а ключи JS-объекта — чувствительны. Будь `res.headers` обычным объектом, было бы нельзя понять, какому ключу должен соответствовать, например, заголовок `Content-Type`:

Скопировать кодJAVASCRIPT

```
res.headers['Content-Type']; // такому?
res.headers['content-type']; // или такому?
res.headers['CONTENT-TYPE']; // а, может, такому? 
```

Поэтому для работы с заголовками есть специальные методы. Чтобы получить значение заголовка, есть метод `get`:

Скопировать кодJAVASCRIPT

```
fetch('https://api.kanye.rest')
  .then((res) => {
    if (res.headers.get('Content-Type').contains('application/json')) {
      return res.json();
    }
  }); 
```

У объекта заголовков есть и [другие методы](https://developer.mozilla.org/en-US/docs/Web/API/Headers).

Единственное отличие заголовков ответа от заголовков запроса: первые можно только читать, но нельзя редактировать.

## Тело ответа

У ответа почти всегда есть тело. Если мы запрашиваем веб-страницу, тело ответа — HTML-код этой страницы. Телом ответа бывает просто текст, картинка или JSON-строка. Чтобы разобрать тело ответа, есть специальные методы:

-   `res.json` — разбирает JSON в объект, этот метод вы уже знаете;
-   `res.text` — разбирает тело как текст;
-   `res.blob` — разбирает тело ответа как бинарные данные: это нужно при получении файлов (изображений, видео, pdf-документов).

В основном мы будем использовать метод `json`, чтобы читать тело запроса как JSON-объект.

Все методы для чтения тела ответа работают асинхронно:

Скопировать кодJAVASCRIPT

```
/* методы разбора тела возвращают промис
их нужно использовать асинхронно */

fetch('https://api.kanye.rest')
  .then(res => res.json())
  .then((result) => {
    console.log(result);
  });

fetch('https://api.kanye.rest')
  .then(res => res.text())
  .then((result) => {
    console.log(result);
  }); 
```

Логичный вопрос: если мы уже получили ответ от сервера, почему его нужно обрабатывать асинхронно? Почему его нельзя сразу посмотреть?

Скопировать кодJAVASCRIPT

```
// почему нельзя было сделать так? удобней ведь

fetch('https://api.kanye.rest')
  .then(res => {
    const json = res.json();
    console.log(json);
  }); 
```

Дело в том, что сервер разбивает данные на небольшие порции, когда отправляет нам ответ. Если от сервера пришёл ответ, это ещё не значит, что пришли все данные. Поэтому сначала мы обрабатываем приход ответа, а затем — данных. Отсюда и асинхронный код.

Можно провести аналогию с телефонным разговором: если наш собеседник снял трубку, для нас это ответ — соединение успешно установлено. Но данные мы получим, только когда собеседник нам что-то скажет.