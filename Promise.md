[[Продвинутый JavaScript]]

Давным-давно, когда все ещё пользовались jQuery, последовательный вызов колбэков мог выглядеть так (не разбирайтесь в этом коде, просто осознайте его монструозность):

Скопировать кодJAVASCRIPT

```
// Показываем общих друзей Ивана и Анны

$.ajax({
  url: 'https://socialnetwork.com/users',
  success: function (data) {
    // достаем нужного пользователя
    const ivan = data.users.find(user => user.name === 'Иван');

    // запрашиваем друзей Ивана
    $.ajax({
      url: `https://socialnetwork.com/users/${ivan.id}/friends`,
      success: function (data) {
        const ivanFriends = data.friends;
        const anna = ivanFriends.find(friend => friend.name === 'Анна');

        // запрашиваем друзей Анны
        $.ajax({
          url: `https://socialnetwork.com/users/${anna.id}/friends`,
          success: function (data) {
            const annaFriends = data.friends;
            let mutualFriends = 0;

            for (let i = 0; i < ivanFriends.length; i += 1) {
              const ivanFriendId = ivanFriends[i].id;
              const isMutual = annaFriends.some(friend => friend.id === ivanFriendId);

              if (isMutual) {
                mutualFriends += 1;
              }
            }

            alert(`У Анны и Ивана ${mutualFriends} общих друзей`);
          }
        });
      }
    });
  }
}); 
```

Мы вызываем колбэк из колбэка из колбэка. И это ещё простой пример.

Такую «лестницу» из колбэков принято называть callback hell или pyramid of doom. Ориентироваться в ней невозможно, поэтому для сложных взаимодействий с сервером колбэками не пользуются. Но выход есть — промисы.

Промис — это часть отдельного API, специально сделанного для работы с асинхронным кодом. Перепишем наш ад колбэков, используя промисы:

Скопировать кодJAVASCRIPT

```
// fetch — это функция для запроса на сервер,
// скоро вы познакомитесь с ней

fetch('https://socialnetwork.com/users')
  .then(getIvan)
  .then(getAnna)
    .then(getMutualFriends)
    .then((mutualFriends) => {
    alert(`У Анны и Ивана ${mutualFriends} общих друзей`)
  }); 
```

Читать такой код уже приятнее и проще. Чтобы стало совсем хорошо, разберёмся как же работают промисы.

## Концепция промисов

В некоторых кафе после заказа дают бипер — специальное устройство, которое начинает вибрировать и сигналить, когда ваш заказ готов. Так вы понимаете, что нужно встать и сходить за своим заказом. Такой бипер — и есть промис.

Когда вы сделали заказ, вы забираете бипер и садитесь за стол. Дальше вы можете заняться своими делами: полистать ленту Facebook, поговорить по телефону, почитать книгу. Когда бипер начнёт светиться и вибрировать, вы сможете закончить, например, разговор по телефону, после чего отправиться за своим заказом.

Промисы — как раз такие биперы для JavaScript. Они позволяют описывать код, который нужно выполнить не сразу, а только когда произойдёт какое-то событие.

## Синтаксис

Часто промисы используют для запросов к какому-то устройству, например, к серверу. Запрос может быть исполнен или отклонён. Поэтому при создании промиса нужно описать, что делать в случае выполнения запроса, а что — в случае отказа. Но прежде чем описывать эту логику, нужно дать понять движку: как определить, обработан наш запрос или нет.

Чтобы «научить» движок обрабатывать запрос, функции `Promise` передают на вход функцию. Она в свою очередь тоже принимает на вход два колбэка: `resolve` и `reject`. Эти колбэки переводят промис в статус «исполнен» или «отклонён».

Скопировать кодJAVASCRIPT

```
const newPromise = new Promise(function (resolve, reject) {
  // Совсем скоро вы научитесь делать настоящие запросы к серверу.
  // А пока будем определять, обработан запрос или нет, случайным образом
    const rand = Math.random() > 0.5 ? true : false;

    if (rand) {
        resolve('Запрос обработан успешно');
    } else {
        reject('Запрос отклонён');
    }
});

// Параметры resolve и reject можно назвать и по-другому,
// но обычно им дают именно такие имена 
```

Код функции, переданной функции `Promise`, исполняется немедленно. Как только вы откроете файл, движок запустит код промиса: создаст переменную `rand`, присвоит ей `true` или `false`. Дальше в зависимости от значения переменной `rand` движок переведёт наш промис в статус «исполнен» или «отклонён».

Дальше нам нужно прописать логику: что делать движку, если промис будет обработан, и что — если отклонён. Для этого у промисов есть три метода:

-   `then` — выполнится, если промис исполнен;
-   `catch` — если отклонён;
-   `finally` — выполнится в любом случае независимо от статуса промиса.

Первые два метода, `then` и `catch`, принимают на вход функцию с одним параметром. Этот параметр — то самое значение, с которым мы вызывали `resolve` и `reject` при создании промиса. В нашем случае это одна из двух строк — `'Запрос обработан успешно'` или `'Запрос отклонён'`:

Скопировать кодJAVASCRIPT

```
// Создаём промис
const newPromise = new Promise(function (resolve, reject) {
  /* Будем определять, обработан запрос
  или нет, случайным образом */
    const rand = Math.random() > 0.5 ? true : false;

    if (rand) {
        resolve('Запрос обработан успешно');
    } else {
        reject('Запрос отклонён');
    }
});

newPromise
  .then(function (value) { // Если промис был обработан

    /* Параметр value хранит значение, переданное методу
    resolve при создании промиса, то есть строку
    "Запрос обработан успешно" */

      console.log(value);
  })
  .catch(function (value) { // Если промис был отклонён

    /* Здесь параметр value будет хранить то значение,
    которое было передано методу reject, то есть строку
    "Запрос отклонён" */

      console.log(value + ', нам жаль :(');
  })
  .finally(function () { // В любом случае
      console.log('Как бы там ни было — запрос мы в глаза видели');
  }); 
```

Ещё раз: вы создаёте промис глобальной функцией `Promise`, которому передаёте на вход колбэк. Этот колбэк принимает на вход 2 функции, которые можно вызвать в теле колбэка.

Первая функция — `resolve`. Она переводит промис в статус «исполнен», а значение, переданное этой функции затем передаётся методу `then`.

Вторая функция — `reject`. Она переводит промис в статус «отклонён». Переданное этой функции значение затем передаётся на вход методу `catch`.

Поэтому, чтобы создать промис, нужно сначала вызвать функцию `Promise`, а затем описать в методах `then` и `catch`, что мы хотим делать в случае успеха, а что — в случае неудачи.

## Цепочка обработки запроса

Предположим, вы создали промис, описали его работу в методах `then` и `catch`. Но что, если одного запроса к серверу недостаточно? К примеру, вы запросили через API список постов одного пользователя. Обработали их, отобрали тот, что вам нужен. А теперь вам нужно получить комментарии к этому посту. Придётся снова идти на сервер и просить на этот раз список комментариев.

Промисы позволяют добавлять задачи в асинхронную очередь. Для этого нужно дописать в коде ещё один `then` или `catch`. Первые `then` и `catch` на странице получат те значения, которые мы передавали на вход функциям `resolve` и `reject`. Все последующие — то, что возвращали предыдущие методы `then` и `catch`.

А вот код функций `firstAction`, `secondAction` и `thirdAction`:

Скопировать кодJAVASCRIPT

```
const newPromise = new Promise(function (resolve, reject) {
    resolve('Раз'); // Сразу получим обработанный промис
});

function firstAction(value) {
  /* Значением value станет то, что мы передали
  функции resolve при создании промиса.
  То есть строка "Раз". */

    return `${value}, два`;
}

function secondAction(value) {
  /* Тут значение value — это то, что вернёт
  предыдущий метод then, то есть строка "Раз, два" */

    return `${value}, три`;
}

function thirdAction(value) {
    console.log(value);
}

newPromise.then(firstAction).then(secondAction).then(thirdAction);

/* В консоли окажется: "Раз, два, три" */ 
```

Цепочку вызовов `then` часто записывают в столбец, отбивая табуляцией:

Скопировать кодJAVASCRIPT

```
newPromise
  .then(firstAction)
  .then(secondAction)
  .then(thirdAction); 
```

Аналогично для отклонённых промисов:

Скопировать кодJAVASCRIPT

```
const newPromise = new Promise(function (resolve, reject) {
    reject('Раз'); // Сразу получим отклонённый промис
});

function firstAction(value) {
    return `${value}, два`;
}

function secondAction(value) {
    return `${value}, три`;
}

function thirdAction(value) {
    console.log(value);
}

newPromise
  .then(firstAction)
  .then(secondAction)
  .catch(thirdAction);

/* В консоли окажется: "Раз", так как newPromise
был отклонён и мы сразу попали в блок catch */ 
```

Обратите внимание: код функции, которую мы передаём методам `catch` и `then`, тоже может приводить к ошибке.

Всегда завершайте цепочки промисов блоком `catch`_._ Это позволит обработать ошибку, если она возникнет в любом `then` из цепочки.

## Статические методы

У `Promise` есть встроенные методы. Они пригождаются при создании промисов. Обратите внимание — сами промисы этими методами не обладают, они есть только у функции `Promise`.

### `Promise.resolve` и `Promise.reject`

Если вы сразу хотите создать исполненный или отклонённый промис, вызывать `new Promise` необязательно. Можно сразу обратиться к методам `Promise.resolve` и `Promise.reject`. Эти методы создают промис, переводят его в статус «исполнен» или «отклонён» соответственно, и записывают как результат промиса — то, что мы передали этим методам.

Скопировать кодJAVASCRIPT

```
Promise.resolve('Этот промис исполнен')
  .then(function (value) {
    console.log(value); // "Этот промис исполнен"
  });

Promise.reject('Этот промис отклонён')
  .catch(function (value) {
    console.log(value); // "Этот промис отклонён"
  }); 
```

### `Promise.all`

У вас на странице может быть несколько промисов. Например, вы запрашиваете картинку с одного сервера, а текст — с другого. И из них нужно собрать пост. Очевидно, нет смысла выкладывать ни картинку без текста, ни текст без картинки. Иными словами — создавать пост мы будем только после того, как оба промиса будут в статусе «исполнен».

Для этого есть статический метод `Promise.all`. Он принимает на вход массив с промисами и выполняет записанный в `then` код, только когда все промисы вернулись со статусом «исполнен»:

Скопировать кодJAVASCRIPT

```
// Создаём первый промис
const firstPromise = new Promise((resolve, reject) => {
  if (someCondition) {
    resolve('Первый промис');
  } else {
    reject();
  }
});

// Создаём второй промис
const secondPromise = new Promise((resolve, reject) => {
  if (secondCondition) {
    resolve('Второй промис');
  } else {
    reject();
  }
});

// Создаём массив с промисами
const promises = [firstPromise, secondPromise]

// Передаём массив с промисами методу Promise.all
Promise.all(promises)
  .then((results) => {
    console.log(results); // ["Первый промис", "Второй промис"]
  }); 
```

Таким образом, промисы — это запросы на асинхронный код. Когда мы создаём промис, мы говорим движку: выполни вот этот код и по результатам переведи промис в статус «исполнен» или «отклонён».

Все дальнейшие действия с результатом запроса прописывают в цепочке методов `then` и `catch`. Они принимают на вход колбэк с одним параметром. В этот параметр записывается либо то, что вернул предыдущий `then` или `catch`, либо то значение, с которым была вызвана функция `resolve` или `reject`.