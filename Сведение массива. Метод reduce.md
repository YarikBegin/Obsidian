[[Массивы, создание, доступ по индексу, длина массива]]

# Сведение массива. Метод reduce

Метод `reduce` перебирает элементы массива и сводит его к одному значению.

Проще всего показать это на примере сложения. Есть массив чисел, нужно посчитать сумму всех его элементов.

Так задачу решают циклом `for`:

Скопировать кодJAVASCRIPT

```
const arr = [1, 2, 3, 4, 5, 6, 7, 8, 9];

let sum = 0; // создадим переменную, где будем хранить сумму

// проходим по всем элементам массива 
// прибавляем каждый из них к переменной-аккумулятору sum 

for (let i = 0; i < arr.length; i += 1) {
  sum += arr[i];
}

console.log(sum); 
```

А можно её решить методом `reduce`.

Он работает как `forEach`: перебирает элементы массива и выполняет для каждого свой код. У колбэка `reduce` те же аргументы, но добавляется один новый. Он ставится на первое место, а «старые» идут за ним: текущий элемент, индекс и исходный массив.

## Новый аргумент. Промежуточное значение

Промежуточное значение — новый первый аргумент и главная особенность `reduce`. На каждой итерации этот аргумент равен тому, что в прошлый раз вернул колбэк.

Скопировать кодJAVASCRIPT

```
const arr = [1, 2, 3, 4, 5, 6, 7, 8, 9];

const sum = arr.reduce(function (previousValue, item) {
  return previousValue + item;
});

console.log(sum); 
```

Запись `return previousValue + item` означает: «прибавь текущий элемент массива к тому, что получилось на предыдущей итерации». Выведем в консоль все промежуточные значения:

Скопировать кодJAVASCRIPT

```
const arr = [1, 2, 3, 4, 5, 6, 7, 8, 9];

const sum = arr.reduce(function (previousValue, item) {
  // для наглядности выведем аргументы в консоль
  console.log(`previousValue: ${previousValue}, item: ${item}`);
  return previousValue + item;
});

console.log(`sum: ${sum}`);

/*
 previousValue: 1, item: 2
 previousValue: 3, item: 3
 previousValue: 6, item: 4
 previousValue: 10, item: 5
 previousValue: 15, item: 6
 previousValue: 21, item: 7
 previousValue: 28, item: 8
 previousValue: 36, item: 9
 sum: 45
*/ 
```

На первой итерации значение `previousValue` — первый элемент массива, `item` — второй. На второй итерации `previousValue` — сумма первых двух элементов, `item` — третий элемент. После последнего `item` в `sum` будет итоговая сумма всех элементов массива.

![image](https://pictures.s3.yandex.net/resources/JS_9_copy_1587227180.gif)

_Иллюстрация работы reduce_

Со сложением разобрались. Но непонятно, зачем нужен `reduce`, когда и `for` работает прекрасно. В бонусном уроке вы узнаете, почему разработчики предпочитают простым циклам методы `map` и `reduce`.

## Начальное значение

На первой итерации промежуточное значение — первый элемент массива. Но это значение можно задать самостоятельно. Тогда действия с массивом начнутся с него.

Первый аргумент метода `reduce` — колбэк. А вот вторым нужно задать промежуточное значение `previousValue` при первой итерации.

Звучит сложно, разберём на примере.

Есть массив `winsAndLoses`. Он хранит историю выигрышей и проигрышей одного игрока в казино. Мы хотим узнать, сколько денег у него осталось после игры, если изначально было 1000.

Передадим `reduce` первым аргументом колбэк, а вторым 1000:

Скопировать кодJAVASCRIPT

```
/* Создадим массив, хранящий в себе историю выигрышей
и проигрышей одного игрока в казино. */
const winsAndLoses = [190, 117, -381, -394, -36, 137, -473, 372, -383];

/* Посчитаем, какая сумма денег останется у этого игрока
к концу вечера, если вначале у него было с собой 1000. */
const total = winsAndLoses.reduce(function (previousValue, item) {
    return previousValue + item;
}, 1000); // Начальное значение передаём методу reduce как второй аргумент.

console.log(total); // 149. Чего ещё ожидать от азартных игр? 
```

Задачу можно решить иначе — не передавать методу `reduce` второй аргумент, а просто прибавить `1000` к переменной `total`:

Скопировать кодJAVASCRIPT

```
const total = 1000 + winsAndLoses.reduce(function (previousValue, item) {
  return previousValue + item;
});

console.log(total); // 149 
```

Это сработает, когда результат работы `reduce` — число или строка. Когда на выходе нужен массив или объект, второй аргумент обязателен.

Есть популярная задача: дан массив, чьи элементы могут повторяться. Нужно создать объект, в котором ключи — это элементы массива, а значения — число повторений соответствующих элементов. Если в исходном массиве есть 3 элемента со значением «яблоко», в конечном объекте должно быть свойство «яблоко» со значением 3.

Тогда методу `reduce` вторым аргументом передают пустой объект:

Скопировать кодJAVASCRIPT

```
const order = ['яблоко', 'банан', 'апельсин', 'банан', 'яблоко', 'банан'];

const result = order.reduce(function (prevVal, item) {
  if (!prevVal[item]) {
    // если ключа ещё нет в объекте, значит это первое повторение
    prevVal[item] = 1;
  } else {
    // иначе увеличим количество повторений на 1
    prevVal[item] += 1;
  }

  // и вернём изменённый объект
  return prevVal;
}, {}); // Начальное значение — пустой объект.

console.log(result); // { яблоко: 2, банан: 3, апельсин: 1 } 
```

Здесь без второго аргумента не обойтись.

## Частые ошибки

Есть две самые популярные ошибки при работе с `reduce`.

**Первая ошибка.** Забыть передать второй аргумент, когда он нужен. Вот что может случиться:

Скопировать кодJAVASCRIPT

```
const order = ['яблоко', 'банан', 'апельсин', 'банан', 'яблоко', 'банан'];

const result = order.reduce(function (prevVal, item) {
  if (!prevVal[item]) {
    prevVal[item] = 1;
  } else {
    prevVal[item] += 1;
  }

  return prevVal;
}); // Забыли передать пустой объект

console.log(result); // "яблоко" 
```

Совсем не то, чего мы ожидали. На первой итерации `prevVal` получило значение первого элемента «яблоко», вернуло его, повторило несколько раз. В результате получилось просто «яблоко», а не свойства со значениями. Чтобы не ошибаться, лучше всегда вызывать `reduce` с указанием начального значения.

**Вторая ошибка.** Забыть `return` внутри колбэка:

Скопировать кодJAVASCRIPT

```
const arr = [1, 1, 2, 3, 5, 8, 13, 21, 34];

const sum = arr.reduce(function (previousValue, item) {
  previousValue = previousValue + item;
});

console.log(sum); // undefined 
```

Если `return` отсутствует, `reduce` в этом примере вернёт `undefined`.

## Суть метода `reduce`

Как работает метод `reduce`:

-   сводит массив к одному значению: числу, массиву, объекту;
-   принимает на вход 2 аргумента: обязательный колбэк и исходное значение его первого аргумента;
-   содержит в колбэке 4 аргумента: промежуточное значение, текущий элемент, его индекс и сам исходный массив.

Метод `reduce` — один из самых сложных. Нормально, если вы не сразу его поняли, поэтому не переживайте: мы говорим о нём не в последний раз. Озарение обязательно постигнет вас, как некогда постигло и нас.