[[React]]

### Списки

Существует ещё одна частая задача — описание разметки для элементов списка. Под списком в данном случае подразумеваются любые однотипные данные, повторяющиеся более одного раза: меню сайта, список пользователей, галерея изображений и т.п.

Например, в ленте сообщений чата, написанного на «Реакте», нужен только массив с данными и код JSX, который описывает разметку одного сообщения, а затем использует цикл, чтобы вывести полный результат.

Предположим, что с сервера мы получаем такой массив с данными о комментариях:

Скопировать кодJAVASCRIPT

```
const comments = [{ 
  id: 1,
  author: 'Лиза',
  text: 'Все уже сдали деньги на субботник?',
}, { 
  id: 2,
  author: 'Джеймс',
  text: 'Никто не видел мой сэндвич?',
}, { 
  id: 3,
  author: 'Грег',
  text: 'Продам мопед',
}]; 
```

Опишем разметку стандартного сообщения:

Скопировать кодJSX

```
<div>
  <h3>{message.author}</h3>
  <div>{message.text}</div>
</div> 
```

Но как передать нужные значения определённого объекта массива `comments` в разметку? Для этого и нужен цикл.

Циклы в JSX реализуются методом `map` массива. При этом каждому внешнему JSX-элементу, создаваемому в цикле, необходимо задать уникальный ключ, для этого используют атрибут `key`.

Скопировать кодJSX

```
ReactDOM.render((
  <div>
    <h2>Сообщения</h2>

    {comments.map((message, i) => (
      // Важный атрибут: key
      <div key={message.id}>
        <h3>{message.author}</h3>
        <div>{message.text}</div>
      </div>
    ))}
  </div>
), document.querySelector('#root')); 
```

Правила «Реакта» всегда требуют задавать ключи при работе со списками. Если этого не сделать, в консоли появится соответствующая ошибка. Они нужны для корректной работы движка, и уже в следующем спринте мы расскажем почему — когда будем разбирать внутреннее устройство «Реакта».

Здесь мы используем уже имеющийся у нас уникальный идентификатор — `message.id`. Использовать идентификаторы в качестве ключа очень удобно, так как обычно они есть у всех данных, которые возвращает API. Если такого идентификатора в данных нет, можно использовать индексы элементов (второй аргумент метода `map`), но только если есть абсолютная уверенность в том, что порядок элементов никогда не меняется:

Скопировать кодJSX

```
ReactDOM.render((
  <div>
    <h2>Сообщения</h2>

    {comments.map((message, i) => (
      // Важный атрибут: key
      <div key={i}>
        <h3>{message.author}</h3>
        <div>{message.text}</div>
      </div>
    ))}
  </div>
), document.querySelector('#root')); 
```

Подробнее изучим списки уже в следующем спринте, но если вы хотите скорее ознакомиться с принципами их работы, вот [статья из документации](https://ru.reactjs.org/docs/lists-and-keys.html).

### Обработчики событий

Вы уже умеете добавлять обработчики событий с помощью `addEventListener`. Кроме того, в обычном HTML есть специальные атрибуты событий `onclick`, `onmouseenter` и другие.

В JSX тоже есть такие атрибуты, только выглядят они немного по-другому:

Скопировать кодJSX

```
function handleClick() {
    console.log('Не дави на меня!');
}

function handleMouseEnter() {
    console.log('Ты мне солнце заслонил!');
}

function handleMouseLeave() {
    console.log('Ну ты чего, нормально же общались!');
}

ReactDOM.render((
    <button
      onClick={handleClick}
      onMouseEnter={handleMouseEnter}
      onMouseLeave={handleMouseLeave}
    >
      Поиграй со мной!
    </button>
), document.querySelector('#root')); 
```

В примере выше значения атрибутов `onClick`, `onMouseEnter` и `onMouseLeave` указывают на JavaScript-функции, которые должны находиться в области видимости.

Полный список поддерживаемых событий можно посмотреть в [документации «Реакта»](https://ru.reactjs.org/docs/events.html#supported-events).