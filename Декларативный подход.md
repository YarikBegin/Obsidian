[[React]]

В предыдущем уроке мы упомянули об отличиях императивного и декларативного подходов.

При императивном подходе разработчик описывает последовательность изменений, которые должны произойти с каждым элементом интерфейса при наступлении определённых событий. Этот подход мы использовали раньше: брали HTML-элемент, подписывались на какое-нибудь событие (например, `click`), задавали обработчик-колбэк, внутри которого уже производили манипуляции с этим или другими элементами. Например, задавали содержимое через `innerHTML`, добавляли CSS-класс через `classList`, меняли стили через объект `style` и т.п.:

Скопировать кодJAVASCRIPT

```
const element = document.querySelector('#myElement');

element.addEventListener('click', () => {
    const element2 = document.querySelector('#myAnotherElement');
    element2.classList.add('active');

    const element3 = document.querySelector('#myText');
    element3.innerHTML = 'It was clicked!';
}); 
```

Скопировать кодHTML

```
<div id="myElement">Click me!</div>

<div id="myAnotherElement">
    <div id="myText">
        Waiting for click...
    </div>
</div> 
```

Декларативный подход позволяет взглянуть на эту задачу под другим углом. Что, если при наступлении события мы будем просто менять значение какой-то переменной, а для всех остальных элементов заранее опишем различные состояния при всех возможных значениях этой переменной?

Скопировать кодJAVASCRIPT

```
const element = document.querySelector('#myElement');
let isClicked = false;

element.addEventListener('click', () => {
    isClicked = true;
}); 
```

При этом предположим, что наш HTML мог бы зависеть от переменных в JavaScript:

Скопировать кодHTML

```
<div id="myElement">Click me!</div>

<div id="myAnotherElement" className={isClicked ? 'active' : ''}>
    <div id="myText">
        {isClicked ? 'It was clicked!' : 'Waiting for click...'}
    </div>
</div> 
```

Такой подход позволяет сократить JavaScript-обработчик до одной строки. Но ещё более важно то, что с его помощью удаётся переместить все варианты текстового содержимого и CSS-классов туда, где описаны сами элементы: прямо в HTML-код.

Таким образом мы разумно распределяем ответственность: JavaScript отвечает лишь за изменение текущего состояния приложения (той самой переменной), а HTML-элементы «сами» определяют (декларируют) то, как они будут выглядеть при разных его состояниях.

Однако, в обычном HTML-коде подобные приёмы невозможны.

Браузер не смог бы считать JavaScript-переменные, а фигурные скобки `{}` в нашем HTML он бы просто проигнорировал. Поэтому выше приведён пример не простого HTML, а так называемого JSX — специального языка шаблонов, проводящего «мост» между HTML и JavaScript.

Декларативный подход оказывается невероятно полезным для поддержания порядка в крупных веб-проектах, а JSX стал одной из главных технологий, используемых в экосистеме «Реакта», и несомненным её преимуществом. В следующем уроке мы наконец подключим «Реакт» и остановимся на нём подробнее.