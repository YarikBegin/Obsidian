[[JavaScript]]

Чтобы корректно обработать ошибку в приложении, важно определить её тип. Это нужно, поскольку часто в реальных приложениях универсальные сценарии неприменимы.

Для определения типа ошибки в JS существует 2 основных подхода:

- по имени ошибки (полю `name`);
- по классу ошибки при помощи оператора `instanceof`.

Для начала поговорим об общих правилах, которых необходимо придерживаться вне зависимости от подхода.

### Основные правила обработки ошибок

Общий подход при написании обработчиков ошибок определённого типа такой: в блок обработки ошибок необходимо добавить условие проверки её типа оператором if и описать обработки в его теле.

Звучит сложновато, но на практике все достаточно просто:

Скопировать кодJAVASCRIPT

```
...
} catch(err) {
  if (условие_проверки_для_ошибки_1) {
     // Логика обработки ошибки 1
     ...
     return;
  }

  if (условие_проверки_для_ошибки_2) {
     // Логика обработки ошибки 2
     ...
     return;
  }
  
  // Логика обработки неизвестных ошибок
  // в этом примере мы просто их логгируем
  console.log(`Произошла неизвестная ошибка ${err.name}: ${err.message}`);
} 
```

При описании обработчиков ошибок, вне зависимости от подхода к определению типа ошибки (условия проверки), придерживайтесь двух правил:

1. В конце catch-блока необходимо описать логику обработки неизвестных ошибок или, как говорят чаще, «ветку обработки ошибок по умолчанию». Это необходимо, чтобы ошибка была обработана в любом случае — даже если она не попадает ни под одно из условий. Если ветка «по умолчанию» отсутствует и ошибка не попадает ни под одно из условий (неизвестная ошибка), то она будет проигнорирована, а это недопустимо.
2. В конце каждого блока-обработчика конкретной ошибки добавляйте остановку выполнения при помощи `return` . Это необходимо, чтобы избежать повторных проверок в последующих if-блоках, когда ошибка уже была обработана. Кроме того, `return` не допускает попадания в «ветку по-умолчанию». Если ошибка уже была обработана, выполнение кода просто завершится раньше. Представим, что бы произошло, если бы `return` не было: сначала ошибка была бы обработана в if-блоке с соответствующим ей именем, а затем — повторно — в обработчике для неизвестных ошибок.

### Определяем тип ошибки по её имени

В мире JS принято использовать уникальные имена для разных типов ошибок. Это позволяет использовать имя ошибки (поле `name`), чтобы определить её тип.

Но есть проблема: для экземпляров стандартных ошибок класса `Error` имя ошибки по-умолчанию также равно `Error`, что не позволит отличать ошибки друг от друга. Чтобы исправить это, разработчики обычно используют кастомные ошибки, о которых мы говорили в [прошлом](https://practicum.yandex.ru/trainer/web/lesson/fcc3da3c-fd85-4812-9166-acc4f85007e0/) уроке.

Чтобы описать обработчик ошибок определённого типа, достаточно добавить соответствующую проверку if в catch-блок. Условие проверки для этого способа выглядит так: `err.name === "ИмяОшибки"`.

А вот сам обработчик при таком подходе:

Скопировать кодJAVASCRIPT

```

...
} catch(err) {
   // Проверяем имя ошибки
   if (err.name === "SomeError") { 
     // Описываем логику её обработки
     ...
     return;
   }
   ...
}  
```

Для каждого типа ошибки необходимо описать собственную проверку.

Подход с использованием имени ошибки простой и наглядный, но у него есть недостатки:

- Разработчику требуется самостоятельно следить за уникальностью имени ошибки. Имена ошибок могут пересекаться не только внутри кода, но и между кодом и сторонними библиотеками. Отследить эти ситуации порой бывает непросто.
- В имени ошибки легко допустить опечатку в блоке проверки. Это приведёт к тому, что условие проверки не сработает и ошибка не будет корректно обработана. Такое бывает, например, если вместо `SomeError` указать `SomeEror`.
- Отсутствует удобный способ описания обработчиков для группы ошибок. Если нужно, чтобы обработчик срабатывал для нескольких типов ошибок, потребуется явно указать каждую из них в условии проверки.  
    Например, если вам необходимо, чтобы обработчик срабатывал для ошибок `SomeError` , `AnotherError` и `ThirdError`, то потребуется описать подобное условие:

Скопировать кодJAVASCRIPT

```
err.name === "SomeError" || err.name === "AnotherErrror" || err.name === "AnotherErrror" 
```

Согласитесь, это не слишком удобно и наглядно.

Этих недостатков лишён второй способ определения типа ошибки — использование оператора `instanceof`.

### Иерархия ошибок. Оператор instanceof

Классы ошибок можно наследовать, как и любые другие классы в JS. Это позволяет описывать иерархию ошибок, группировать их и описывать общую логику обработки.

В этом случае используют оператор `instanceof`. Он позволяет определить, является ли указанный объект (ошибка) экземпляром некоторого класса c учётом иерархии наследования.

Например, чтобы проверить, является ли `err` ошибкой `SomeErrorName` или её частным случаем (классом-наследником), пишут следующее: `err instanceof SomeErrorName`. Если это так, результатом выражения будет `true`, если иначе — `false`.

Чтобы лучше понять, как работает оператор `instanceof`, рассмотрим пример. Опишем 3 класса ошибок: `SomeErrorName`, `AnotherErrorName` и `ChildOfAnotherErrorName`. При этом укажем, что `ChildOfAnotherErrorName` — наследник (то есть частный случай) `AnotherErrorName`.

Затем проверим результат, который вернёт нам `instanceof` для каждой из них:

Скопировать кодJAVASCRIPT

```
class SomeError extends Error {};
class AnotherError extends Error {};
class ChildOfAnotherError extends AnotherError;

let someError = new SomeError("Ошибка SomeError")
let anotherError = new AnotherError("Ошибка AnotherError")
let childOfAnotherError = new ChildOfAnotherError("Ошибка-наследник AnotherError")

// Вернет true, someError - экземпляр SomeError
console.log(someError instanceof SomeError)

// Вернет false, anotherError - экземпляр AnotherError, а не SomeError
console.log(anotherError instanceof SomeError)

// Вернет true, childOfAnotherError - экземпляр ChildOfAnotherError
// а ChildOfAnotherError - наследник AnotherError
console.log(childOfAnotherError instanceof AnotherError)

// Вернет true, childOfAnotherError - экземпляр ChildOfAnotherError
console.log(childOfAnotherError instanceof ChildOfAnotherError)
 
```

Обратите внимание: несмотря на то, что в условии проверки указан класс `AnotherError`, выражение вернуло `true`, поскольку `childOfAnotherError` — наследник `AnotherError`.

Именно благодаря этому свойству нам достаточно одного обработчика для обработки групп ошибок. Поскольку в условии проверки указывается конкретный класс, мы застрахованы от проблем, связанных с пересечением имён ошибок и опечаток в условиях проверки. IDE подскажет, если класс с указанным именем отсутствует.

Когда для ошибки-наследника требуется логика обработки, которая отличается от других ошибок этой группы, обработчик помещается в catch-блоке выше «группового» по коду.

Скопировать кодJAVASCRIPT

```
class ErrorGroup extends Error {};
class FirstChildOfErrorGroup extends ErrorGroup;
class SecondChildOfErrorGroup extends ErrorGroup;

try {
....
} catch(err) {
// Отдельный обработчик для ошибки FirstChildOfAnotherError
if (err instanceof FirstChildOfErrorGroup) { ... }

// Обработчик для группы ошибок 
if (err instanceof ErrorGroup) { ... }

} 
```

Иерархия ошибок организовывает код, объединяя ошибки одного типа. Например, ошибки в работе с базой данных, ошибки валидации и другие.

Один из самых популярных сценариев применения группировки ошибок — описание ошибок API. В таком случае вместо того, чтобы нагромождать условия проверки, разработчику достаточно описать общий класс `HttpError`, а сами ошибки (частные случаи), например, `DocumentNotFoundError` (ошибка 404) и `ForbiddenError` (ошибка 403), реализовать в качестве его наследников. В таком случае нам достаточно описать один обработчик для `HttpError`, внутри которого возвращать пользователю ошибку.

Если нам потребуется описать дополнительную ошибку, например `Unauthorized` (ошибка 401), то нам не понадобится изменять условие проверки, чтобы она была корректно обработана.

На этом тема подходит к концу. Пора переходить к завершающему уроку.