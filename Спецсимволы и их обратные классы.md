[[JavaScript]]

В прошлом уроке мы говорили о флагах — одной из трёх сущностей для работы с регулярными выражениями. Теперь переходим к спецсимволам. Расскажем об основных, а ещё разберём, что такое обратные классы спецсимволов. Поехали.

Представьте, что к нашей статье о телефонах появились новые комментарии. Теперь из всех комментаторов мы хотим отобрать пользователей тех моделей, у которых есть s на конце: Xs, 5s, 6s. Напишем регулярку:

Скопировать кодJAVASCRIPT

```
const regex = /iPhone .s/gi; // Поставим точку вместо номера модели 
```

Нам приходит на помощь точка. В шаблоне регулярного выражения она заменяет любой символ. Неважно, какая цифра стоит перед s, поэтому на её место в шаблоне мы ставим точку.

В шаблоне может быть сколько угодно точек.

Скопировать кодJAVASCRIPT

```
const str = `
  Не помню, как именно его зовут:
  то ли Сортини, то ли Сордини.
  Быть может, и Сардини, через «а».
`;

const regex = /С.р.ини/g; // Точки в регулярном выражении заменяют любой символ.

str.match(regex); // [ "Сортини", "Сордини", "Сардини" ] 
```

Но у точки есть одна слабость: она не найдёт перенос строки.

Скопировать кодJAVASCRIPT

```
const str = `Внезапный
перенос`;

const regex = /Внезапный.перенос/;

str.match(regex); // null 
```

Но не беда — эту проблему можно решить спецсимволами.

## Спецсимволы

Спецсимволы — это такие конструкции из символов в регулярных выражениях, которые позволяют искать не один символ, а сразу группу.

Есть одиночные спецсимволы — точка, например. Но многие спецсимволы — это буквы. И чтобы движок понимал, что это не простая буква, а особый символ, в регулярном выражении такой символ нужно экранировать — то есть поставить перед ним обратный слеш `\w`.

Если экранировать спецсимвол, который должен идти без слеша, движок будет его воспринимать как обычный символ. Например, если поставить обратный слеш перед точкой, движок будет искать только точки, а не любые символы:

Скопировать кодJAVASCRIPT

```
const str1 = 'yandex.ru/maps/';
const regex1 = /\.ru/; // экранировали точку
const regex2 = /\/maps/; // экранировали слеш перед словом maps

str1.match(regex1); // [ ".ru" ]
str1.match(regex2); // [ "/maps" ]

// Чтобы найти обратный слеш, его тоже нужно экранировать

const str2 = 'C:\\';
const regex3 = /\\/; // экранировали слеш

str2.match(regex3); // [ "\" ] 
```

### Спецсимвол `\w`

Этот спецсимвол говорит движку искать любую цифру, латинскую букву или нижнее подчёркивание:

Скопировать кодJAVASCRIPT

```
const str = 'Простите, я отправил старую версию файла диплом_финал_2_копия_3.docx. Не смотрите не неё. Высылаю вам актуальную диплом_финал_2_копия_4.docx';

const regex = /диплом\wфинал\w\w\wкопия\w\w.docx/g;

str.match(regex);

// [ "диплом_финал_2_копия_3.docx", "диплом_финал_2_копия_4.docx" ] 
```

У спецсимвола `\w` есть обратный класс: `\W`. Если `\w` ищет цифры, латинские буквы и нижние подчёркивания, то `\W` ищет всё что угодно: знаки вопроса, пробелы, слеши, кириллические символы, — но только не цифры, буквы базовой латиницы и нижние подчёркивания.

Итак, обратный класс — это всё равно, что сказать «ищи НЕ такой-то спецсимвол».

Скопировать кодJAVASCRIPT

```
const str = `
  Даты основания некоторых IT-компаний:
  Yandex: 23.09.1997
  Apple: 01/04/1976
  IBM: 16-06-1911
`;

const regex = /\w\w\W\w\w\W\w\w\w\w/g;

/* цифры в дате мы обозначили строчной \w, а разделители —
заглавной \W. Разделитель это НЕ цифра, НЕ латинская буква
и НЕ нижнее подчёркивание. */

str.match(regex); // [ "23.09.1997", "01/04/1976", "16-06-1911" ] 
```

### Спецсимвол `\d`

Спецсимвол `\d` совпадает с любой цифрой:

Скопировать кодJAVASCRIPT

```
const str = 'Владивосток 2000';
const regex = /\d\d\d\d/g;

str.match(regex); // [ "2000" ] 
```

Обратный класс этого символа совпадает со всеми не-цифрами: буквами, пробелами, спецсимволами.

Скопировать кодJAVASCRIPT

```
// найдёт все символы, кроме цифр

const someSymbol = /\D/g;
const string = 'I was born in 1987';

string.match(someSymbol);

// ["I", " ", "w", "a", "s", " ", "b", "o", "r", "n", " ", "i", "n", " "] 
```

### Спецсимвол `\s`

Спецсимвол `\s` ищет «пустоты» в тексте: пробелы (в том числе неразрывные), переносы строк и табуляции.

Скопировать кодJAVASCRIPT

```
const str = 'Сдают паспорта,\n' +
                    '              и я' +
                    '                сдаю';

const regex = /\s/g;

str.match(regex).length; // 32 — Маяковский любил пробелы 
```

Его обратный класс `\S` ищет любые символы, только не пробелы, табуляции и переносы:

Скопировать кодJAVASCRIPT

```
const str = 'Сдают паспорта,\n' +
                    '              и я' +
                    '                сдаю';

const regex = /\S/g;

str.match(regex).length; // 22

// букв с запятыми получилось на десяток меньше 
```

### Ещё немного о методе `String.match`

Мы говорили, что он возвращает массив найденных значений. И у этого массива есть важная особенность.

Если передать методу `String.match` регулярное выражение без флага `g`, полученному массиву будут определены дополнительные свойства:

Скопировать кодJAVASCRIPT

```
const str = 'тро-ло-ло';
const result = str.match(/ло/);

result[0]; // "ло"
result.index; // 4
result.input; // "тро-ло-ло" 
```

Если искать по регулярному выражению с флагом `g`, дополнительных свойств в итоговом массиве не будет. Мы получим просто массив, состоящий из строк:

Скопировать кодJAVASCRIPT

```
const str = 'тро-ло-ло';
const result = str.match(/ло/g);

result; // ["ло", "ло"] 
```

### Спецсимвол `\b`

Возвращаемся к спецсимволам. `\b` означает границу слова. Движок считает границей слова:

- начало строки;
- конец строки;
- любой символ, кроме цифр, латинских букв и нижнего подчёркивания.

Так мы можем находить символы в начале и в конце строки:

![image](https://pictures.s3.yandex.net/resources/sprint_10___1__236_1588494196.png)

Скопировать кодJAVASCRIPT

```
const string = 'sadness';

string.match(/\bs/).index; // 0 — это первая буква s
// спецсимвол указал границу левее неё, т. е. начало

string.match(/s\b/).index; // 6 - а это последняя
// спецсимвол указал границу правее неё, т. е. конец 
```

Обратите внимание: любая нелатинская буква прочитывается движком как отдельное слово. Поэтому с кириллицей спецсимвол `\b` не работает.

Скопировать кодJAVASCRIPT

```
/* Попробуем найти в номере автомобиля код региона.
Поскольку он в конце строки и состоит из цифр,
составим такое регулярное выражение: */

'А333НР99'.match(/\d\d\b/);

// ["33", index: 2, input: "А333НР99", groups: undefined]

/* Мы хотели получить регион, но получили цифры
в середине номера, потому что движок счёл кириллический
символ «Н» за конец слова «333». */ 
```

Но на самом деле в автомобильных номерах допускаются только буквы, подобные которым есть в латинице. Если записать номер латинскими буквами, всё получается:

Скопировать кодJAVASCRIPT

```
'A333HP99'.match(/\d\d\b/);
//["99", index: 6, input: "A333HP99", groups: undefined] 
```

Также есть обратный класс `\B` — он ищет не конец слова: цифру, латинскую букву или нижнее подчёркивание. Таким образом, `\B` делает то же самое, что `\w`.

Полный перечень спецсимволов [можно посмотреть на MDN](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/RegExp).