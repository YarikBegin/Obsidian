[[Валидация]]

Встроенная браузерная валидация — простой способ работы с формой. Но у неё есть недостатки:

-   стиль сообщения об ошибке нельзя настроить, оно в каждом браузере выглядит по-своему;
-   сообщение об ошибке показывается только для первого некорректно заполненного поля, а не для всех сразу;
-   валидация с применением псевдоклассов не показывает сообщение об ошибке;
-   поле невозможно валидировать на основе значения другого поля. Так нельзя проверить, совпадают ли значения полей «Пароль» и «Повторите пароль».

JavaScript решает эти проблемы:

-   поля можно менять сразу во время ввода данных — не нужно нажимать «Отправить», чтобы увидеть сообщения об ошибке;
-   внешний вид ошибки полностью настраивается — можно поменять стили, отображение, текст и сделать их едиными для всех браузеров.

## Атрибут `novalidate`

Хорошие новости: пригодится всё, что вы изучили в прошлом уроке. В JS тоже применяется встроенная браузерная валидация. Используются те же атрибуты, но отключаются стандартные сообщения об ошибке. За показ ошибок и блокировку формы теперь отвечает JS.

Сперва сообщите браузеру о том, что стандартные сообщения об ошибке не нужны. Для этого укажите атрибут `novalidate` у формы:

Скопировать кодHTML

```
<form class="form" novalidate>
  <input class="form__input" type="url" placeholder="Адрес" required>
  <button class="form__submit">Войти</button>
</form> 
```

Теперь стандартных браузерных ошибок не будет. Осталось получить доступ к данным валидации в JS.

## Объект `ValidityState`

В JS есть `ValidityState` — встроенный объект для сверки данных. Он присутствует в каждом поле ввода и тесно связан с его html-атрибутами. Само свойство называется `validity`.

![image](https://pictures.s3.yandex.net/resources/Untitled_30_1659373485.png)

Свойство `validity` — это объект из 11 свойств с булевыми значениями. Разберём основные свойства:

-   `valueMissing` — принимает `true`, когда обязательное поле пустое;
-   `typeMismatch` — принимает `true`, когда ввели неправильные значения данных для атрибута `type`. Это круто работает в связке с `type="email"` и `type="url"`;
-   `tooLong` — принимает `false`, когда количество символов не превышает значение атрибута `maxlength`. А `true` не существует в современных браузерах. Невозможно ввести больше символов, чем указано в `maxlength`;
-   `tooShort` — принимает `true`, когда количество символов не превышает значение атрибута `minlength`.

Как видите, для одних свойств корректное значение — это `true`, для других — `false`.

Ещё в объекте `validity` есть свойство `valid`. В нём находится итоговое решение проверки данных. Если во всех других 10 свойствах значения корректны, поле ввода валидно и свойство `valid` приобретает значение `true`.

## «Живая» валидация

Когда в поле вводят данные, значения свойств объекта `validity` меняются. Для этого не нужно отправлять форму.

Как только поле выполнит все условия атрибутов, свойство `valid` приобретёт значение `true`.

«Живая» проверка данных происходит одновременно с тем, как пользователь вводит в поле данные. Для этой проверки есть слушатель событий `input`. Он срабатывает при любом изменении данных в поле, на котором висит обработчик:

Скопировать кодJAVASCRIPT

```
// Вынесем все необходимые элементы формы в константы
const formElement = document.querySelector('.form');
const formInput = formElement.querySelector('.form__input');

// Слушатель события input
formInput.addEventListener('input', function (evt) {
  // Выведем в консоль значение свойства validity.valid поля ввода, 
  // на котором слушаем событие input
  console.log(evt.target.validity.valid);
}); 
```

Данные проверяются на корректность, пока пользователь их вводит.

Так можно получать данные о валидации в JS. Теперь на их основе нужно показать пользователю, какие ошибки допущены. Займёмся этим в следующем уроке, а пока попрактикуйтесь со значениями свойств `ValidityState` в заданиях.