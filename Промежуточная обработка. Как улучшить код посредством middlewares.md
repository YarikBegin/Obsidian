[[JavaScript]]

В заданиях предыдущего урока вы описали логику роутинга:

Скопировать кодJAVASCRIPT

```
router.get('/users/:id', (req, res) => {
  // логика обработки начиналась
  const { id } = req.params;

  if (!users[id]) {
    res.send({ error: 'Такого пользователя нет' });
    return;
  }

  // логика обработки заканчивалась, отправлялся ответ
  res.send(users[id]);
}); 
```

Это отличный код для поставленной задачи. Но часто придётся реализовывать что-то более глобальное, например, логирование или аутентификацию пользователя. Если прописывать эту логику внутри роутеров, кода станет так много, что в нём будет сложно разобраться.

Эту проблему решают мидлвэры (middleware) — функции промежуточной обработки. Они позволяют описать логику обработки запроса в отдельном модуле, что сокращает код роутера.

В мидлвэр удобно выносить и типовые задачи. Например, для любого запроса сервер проверяет наличие записи в базе данных. Благодаря мидлвэру эту логику не нужно прописывать в каждом роутере.

### Создаём мидлвэр

Разобьём код роутера на отдельные функции: одна служит для проверки, есть ли пользователь в нашей базе, другая — для отправки ответа с нужным пользователем.

Начнём с ответа:

Скопировать кодJAVASCRIPT

```
// Вынесём отправку ответа в отдельную функцию
const sendUser = (req, res) => {
  const { name, age } = users[req.params.id];
  res.send(`Пользователь ${name}, ${age} лет`);
}; 
```

Переходим ко второй функции — мидлвэру. Она проверяет, существует ли пользователь:

- если нет, отправляет в ответе ошибку;
- если да, вызывает функцию отправки ответа с конкретным пользователем — уже написанную `sendUser`.

Переведём это на джаваскриптовый:

Скопировать кодJAVASCRIPT

```
// Проверим, существует ли пользователь:
const doesUserExist = (req, res, next) => {
  if (!users[req.params.id]) {
    res.send(`Такого пользователя не существует`);
    return;
  }

  next(); // вызываем next
};

const sendUser = (req, res, next) => {
  res.send(users[req.params.id]);
}; 
```

Если пользователь найден, вызовем функцию, переданную третьим аргументом. Осталось написать обработчик запроса:

Скопировать кодJAVASCRIPT

```
router.get('/users/:id', doesUserExist);
router.get('/users/:id', sendUser); 
```

Тут и начинается магия экспресса. Фреймворк написан так, что если для одного запроса есть несколько обработчиков, он будет считать функцией `next` следующий обработчик этого же запроса.

Разберём код ещё раз. Вот функция doesUserExist:

Скопировать кодJAVASCRIPT

```
const doesUserExist = (req, res, next) => {
  if (!users[req.params.id]) {
    res.send(`Такого пользователя не существует`);
    return; // если пользователя нет, мы выйдем из функции и больше ничего происходить не будет
  }

  next(); // если движок дошёл до функции next, он будет искать следующий обработчик того же запроса
}; 
```

Допустим, нам нужен ещё один мидлвэр, чтобы проверять уровень доступа пользователя. Мы также опишем его логику и запустим колбэк `next`, а затем просто вставим новый обработчик запроса между уже существующими:

Скопировать кодJAVASCRIPT

```
router.get('/users/:id', doesUserExist);
router.get('/users/:id', doesUserHavePermission); // Просто добавили обработчик, не трогая код других мидлвэров
router.get('/users/:id', sendUser); 
```

Обратите внимание: колбэк мидлвэра принято всегда называть `next`. Старайтесь не отходить от этого правила, чтобы ваш код был понятен другим разработчикам.

### Подключаем мидлвэр

Для использования мидлвэр мы будем пользоваться методом `use`, но с одним параметром — самим мидлвэром:

Скопировать кодJAVASCRIPT

```
app.use(middleware); 
```

Скопировать кодJAVASCRIPT

```
// index.js

const express = require('express');
const routes = require('./routes.js');

const { PORT = 3000 } = process.env;
const app = express();

const logger = (req, res, next) => {
  console.log('Запрос залогирован!');
  next();
};

app.use(logger);
app.use('/', router);

app.listen(PORT, () => {
    console.log(`App listening on port ${PORT}`);
}); 
```