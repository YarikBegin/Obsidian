[[JavaScript]]

Элементарные операции не зависят от структуры и объёма данных, с которыми работают. К ним относят присвоение значений переменным (`a = 5`), математические операции (`2*2`), обращение к полям объекта (`obj.a`), проверка логических условий (`a < 5`). Все они работают достаточно быстро, поэтому при расчёте сложность таких операций принимают за единицу и просто считают их количество.

Но бывают операции, сложность которых не равна единице, например, вызов функции. Методы `map` и `join` перебирают элементы массива, поэтому имеют сложность `О(n)`. Если мы используем их в коде, то должны учитывать это при расчётах. Оценим сложность функции:

Скопировать кодJAVASCRIPT

```
function printNames(people) {
  const names = people.map(p => p.name); // О(n), считаем как n операций
  return names.join(', '); // О(n), считаем как n операций
} 
```

Сложность функции `printNames` равна сумме сложностей двух вызываемых внутри неё функций: `map` и `join`.

![image](https://pictures.s3.yandex.net/resources/S15_1_1605882954.png)

Сложность операции `join` зависит только от длины массива, поэтому равна `О(n)`. Сложность операции `map` зависит от размера массива и от количества операций внутри функции-колбэка. Здесь сложность равна `О(n * 1)`, ведь в теле колбэка метода `map` мы совершаем всего одну операцию.

Итоговая сложность функции `printNames` равна `О(n) + О(n) = О(2n)`. Опустим константу 2 и получим сложность `О(n)`.

В работе не нужно всегда считать все операции. Достаточно суммировать сложность операций, которые зависят от размера входных данных, а элементарные операции опустить.

Проверим. Усложним код из предыдущего примера:

Скопировать кодJAVASCRIPT

```
function printNames(people) {
  const names = people.map(p => {
        if (p.fullName) {
            return p.fullName;
        } else {
            return [p.firstName, p.middleName, p.lastName].join(' ');
        }
    });

  return names.join(', ');
} 
```

Операций внутри функции-колбэка `map` стало больше, но они не зависят от размера входных данных. Какой бы длинный массив `people` мы не передали, количество операций в колбэке метода `map` не изменится, поэтому не нужно считать их точное число. Примем их за константу `k` и получим сложность функции `map`: `k * О(n)=О(n)`. В итоге вышло `О(n)`, как и в алгоритме с меньшим количеством операций.

Рассчитайте сложность функции `swap`.

Скопировать кодJAVASCRIPT

```
function swap(arr, i, j) {
    const tmp = arr[i];
    
    arr[i] = arr[j];
    arr[j] = tmp;
} 
```

`О(n^3)`

Неправильный ответ

`О(n)`

Неверно. Как думаете, зависит количество операций от размера массива и переменных? Нет. Функция `swap` выполняет 3 операции, независимо от объёма входного массива и переменных `i` и `j`. Поэтому её сложность константная –– `О(1)`.

`О(n^2)`

Тоже правильный ответ

`О(1)`

Верно! Функция `swap` выполняет 3 операции, независимо от размера массива `arr` и индексов `i` и `j`. Поэтому её сложность константная –– `O(1)`.

Рассчитайте сложность функции `findMinIndex`.

Скопировать кодJAVASCRIPT

```
function findMinIndex(arr, start) {
    let min = arr[start];
    let minIndex = start;

    for (let i = start + 1; i < arr.length; i++) {
        if (arr[i] < min) {
            min = arr[i];
            minIndex = i;
        }
    }

    return minIndex;
} 
```

Неправильный ответ

`О(n^3)`

Неверно. Обратите внимание на цикл по элементам массива. Какая это сложность?

Тоже правильный ответ

`О(n)`

Верно! Функция `findMinIndex` выполняет цикл по элементам массива `arr` и поэтому линейно зависит от его размера.

`О(n^2)`

`О(1)`