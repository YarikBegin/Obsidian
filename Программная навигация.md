[[React Router]]

В приложении может потребоваться навигация не только по ссылкам, но и после выполнения определённой логики. Например, после успешной авторизации нужно перенаправить пользователя на другую страницу. Или переадресовать его на страницу с предупреждением, если пользователь пытается перейти в раздел сайта, для просмотра которого у него нет прав.

Инструменты для решения этих задач доступны в библиотеке React Router DOM.

## Хук `useNavigate`

Хук `useNavigate` возвращает функцию, которую мы можем использовать для навигации:

Скопировать кодJSX

```
import { useNavigate } from "react-router-dom";

//...

const navigate = useNavigate(); 
```

Функция принимает два аргумента.

Первый аргумент — строка или число. Если мы передаём строку, то выполняется навигация на роут, который соответствует этой строке:

Скопировать кодJSX

```
navigate('/destination'); 
```

Если строка строка начинается с `/`, то это абсолютный путь. В таком случае при вызове функции текущий путь полностью заменится новым. Если строка не начинается с `/`, то это относительный путь. Он добавляется к текущему: `currentPath + / + destination` .

Если мы передаём число, то выполняется перемещение по истории. Это работает так же, как стрелочки «Назад» и «Вперёд» в браузере. Положительное число указывает, на сколько шагов впёред по истории необходимо переместиться; отрицательное число указывает, на сколько шагов назад по истории необходимо переместиться.

Скопировать кодJSX

```
function CustomComponent() {
    const navigate = useNavigate();

    function goBack() {
        navigate(-1);
    }
    function goForward() {
        navigate(1);
    }

    return (
        <div>
            <button onClick={goBack}>go back</button>
            <button onClick={goForward}>go forward</button>
        </div>
    );
} 
```

Второй аргумент — объект с двумя полями:`replace` и `state`.

В поле `replace` можно передать `true` или `false`. Значение по умолчанию — `false`. При передаче `true` мы заменяем текущую позицию в истории на новую. Если передать `false` или вообще не указывать это поле, то мы добавим новую позицию в историю.

Значение `true` бывает полезно передать, если мы перенаправляем пользователя с закрытой или устаревшей страницы. Это позволяет при перемещении по истории не попасть снова на такую страницу.

Скопировать кодJSX

```
function OldHomePage() {
    const navigate = useNavigate();

    function goToNewPage() {
        navigate('/new-page', { replace: true });
    }

    return (
        <div>
            <button onClick={goToNewPage}>Попробуйте нашу новую страницу</button>
        </div>
    );
} 
```

В поле `state` можно передать объект, который будет помещён в стек истории. У каждой точки в истории может быть своё состояние. Находясь на точке, мы можем получить доступ к этому состоянию.

## Компонент `Navigate`

Компонент `Navigate` перенаправляет пользователя на другую страницу. Он имеет схожие с функцией `navigate` параметры:

-   `to` — куда мы хотим навигироваться;
-   `replace` — заменять или нет запись в стеке истории;
-   `state` — JS-объект с данными, который связан с позицией в истории. Его часто используют в веб-приложениях после авторизации. Например, чтобы авторизованный пользователь не мог вернуться на страницу входа.

Посмотрим, как это работает на практике. Используем тернарный оператор внутри маршрута, чтобы проверить значение `loggedIn` и определить, вошёл ли пользователь в систему. Если вошёл, то пользователь увидит компонент своего профиля `UserProfile`. В противном случае `Navigate` отправит пользователя на экран авторизации:

Скопировать кодJSX

```
<Route path="/my-profile">
  {!loggedIn ? <Navigate to="/log-in" /> : <UserProfile />}
</Route> 
```

Теперь вам под силу создать такое приложение, в котором пользователь сможет перемещаться вперёд и назад сколько ему вздумается. А ещё вы сумеете настроить переадресацию в тех случаях, когда она нужна.