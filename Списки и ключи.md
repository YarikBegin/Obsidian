[[React]]

В предыдущем спринте мы рассказывали [об алгоритме «Реакта», который называется “reconciliation”.](https://praktikum.yandex.ru/trainer/web/lesson/b3814563-4d75-427e-9fa9-92f7f6d3b4a7) Он неплохо справляется со своей задачей, но иногда ему требуется наша помощь.

Пробегаясь по ветвям дерева виртуального DOM, алгоритм сравнивает узлы в новом и старом дереве по двум признакам:

-   по типу — это может быть элемент, компонент, строка или пустой узел;
-   по названию тега или имени компонента.

Если хотя бы один из этих признаков не совпадает, значит, узел и все его дочерние узлы в дереве должны быть полностью заменены. Старый узел будет удалён из DOM, а компонент — размонтивирован. На их место будет вставлена новая ветвь элементов. Или не будет, если в обновлённом виртуальном дереве на их месте ничего нет.

В противном случае, когда оба условия выполняются, значит, перед нами тот же самый узел. Если это DOM-элемент, «Реакт» при необходимости обновит его атрибуты и отправится проверять его «детей» — вглубь кроны дерева. Если это компонент, «Реакт» обновит его пропсы и повторно вызовет рендер, чтобы сравнить изменения в ветви, за которую отвечает этот компонент.

Этот простой алгоритм работает отлично, за исключением некоторых случаев.

### Списки в «Реакте»

Представьте, что вы пишете приложение-мессенджер, в котором есть список чатов, отсортированных по времени последнего сообщения. Каждый элемент этого списка — экземпляр компонента `Chat`. Массив с данными чатов приходит из API в таком виде:

Скопировать кодJSX

```
const chats = [{
  id: 10,
  name: 'Gregory',
  lastMessageAt: '20:45',
}, {
  id: 5,
  name: 'Allison',
  lastMessageAt: '12:31',
}, {
  id: 3,
  name: 'James',
  lastMessageAt: '07:40',
}]; 
```

В JSX работа со списками осуществляется с помощью метода `map`:

Скопировать кодJSX

```
ReactDOM.render((
  <>
    <h2>Чаты</h2>
    {chats.map((chat) => (
      <Chat id={chat.id} name={chat.name} lastMessageAt={chat.lastMessageAt} />
    ))}
  </>
), document.querySelector('#root')); 
```

При этом сам компонент `Chat` может выглядеть предельно просто:

Скопировать кодJSX

```
function Chat(props) {
  return (
    <div className="chat">
      <img src={`img/${props.id}.png`} width="75" />
      <h2>{props.name}</h2>
      <div className="date">{props.lastMessageAt}</div>
    </div>
  );
} 
```

А такое получится приложение:

![image](https://pictures.s3.yandex.net/resources/S11.4_01_keys_1595768439.png)

Когда в один из чатов придёт новое сообщение, он должен переместиться в верх списка, а все остальные чаты должны сдвинуться на одну позицию вниз. Но когда это произойдёт, алгоритм «Реакта» начнёт по порядку сравнивать старое и новое дерево элементов и не сможет понять, что узлы поменялись местами. Тип узла и имя компонента останутся прежними для каждого элемента списка, поэтому он начнёт искать изменения в их внутреннем содержимом (аватарках, именах пользователей, времени) и сделает много лишних действий в DOM.

![image](https://pictures.s3.yandex.net/resources/S11.4_02_keys_1595768475.png)

Есть и более серьёзная проблема: если в этих компонентах хранится внутреннее состояние, например счётчики непрочитанных сообщений, то их значения перемешаются, потому что «Реакт» всего лишь заменит текстовое содержимое у всех чатов, оставив сами экземпляры компонентов в предыдущем порядке.

На самом же деле ему достаточно было бы обновить содержимое только одного чата и переместить его DOM-элемент в верх списка:

![image](https://pictures.s3.yandex.net/resources/S11.4_03_keys_1595768513.png)

Чтобы помочь алгоритму понять, что элементы просто поменялись местами, нужно применить специальный атрибут `key` (англ. «ключ») — уникальный идентификатор узла, который используется как третий отличительный признак при сравнении. Теперь, когда «Реакт» будет сравнивать новые списки чатов, он сможет опираться на этот атрибут, чтобы понять, что элементы изменили свой порядок внутри списка.

Скопировать кодJSX

```
ReactDOM.render(
  <>
    <h2>Чаты</h2>
    {chats.map((chat) => (
      <Chat
        key={chat.id}
        id={chat.id}
        name={chat.name}
        lastMessageAt={chat.lastMessageAt}
      />
    ))}
  </>,
  document.querySelector("#root")
); 
```

### Ключи вне списков

У `key` есть и другие применения, кроме списков. Например, после выбора чата может понадобиться заменить весь список сообщений, за который отвечает компонент `MessageList`. Иногда самое простое решение — дать команду «Реакту» полностью демонтировать старый компонент `MessageList` и смонтировать на его месте новый. Чтобы это сделать, компоненту можно задать новый ключ, соответствующий ID выбранного чата:

Скопировать кодJSX

```
ReactDOM.render(
  <>
    <h2>Чаты</h2>
    {chats.map((chat) => (
      <Chat
        key={chat.id}
        id={chat.id}
        name={chat.name}
        lastMessageAt={chat.lastMessageAt}
      />
    ))}

    <h2>Сообщения</h2>
    <MessageList key={selectedChatId} />
  </>,
  document.querySelector("#root")
); 
```

Таким образом с помощью смены ключа мы сообщаем «Реакту», что текущий экземпляр компонента `MessageList` нужно полностью заменить новым экземпляром.