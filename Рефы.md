[[React]]

Рефы (англ. ref от reference, «указатель») — ещё один способ хранения данных внутри функциональных компонентов. Они используются сразу для двух целей.

### Прямой доступ к DOM-элементам

«Реакт» реализует декларативный подход к описанию веб-интерфейса. Это означает, что обычно разработчику не нужно взаимодействовать с реальными DOM-элементами и обращаться к ним напрямую. Всё необходимое можно делать в JSX: устанавливать CSS-классы, задавать стили или создавать подписку на события.

Из этого правила есть исключения, и иногда наличие прямого указателя на реальный DOM-элемент необходимо. «Реакт» предоставляет такой механизм — рефы. В [официальном руководстве React](https://ru.reactjs.org/docs/refs-and-the-dom.html) приводятся ситуации, в которых использование рефов для этой цели оправдано:

-   управление фокусом, выделение текста или воспроизведение медиа;
-   императивный вызов анимаций;
-   интеграция со сторонними DOM-библиотеками.

**Для функциональных компонентов** существует специальный хук `useRef`. Он возвращает объект, который с помощью JSX-атрибута `ref` можно присвоить любому элементу, чтобы получить доступ к нему. Этот объект содержит одно единственное поле `current`. Именно в это поле React запишет указатель на DOM-элемент, когда будет формировать DOM-дерево.

Так это выглядит:

Скопировать кодJSX

```
function VideoPlayer() {
  const videoRef = React.useRef(); // записываем объект, возвращаемый хуком, в переменную

  function handleClick() {
    videoRef.current.play(); // вызываем нужный метод на поле current объекта
  }

  return (
    <>
      <video ref={videoRef} src="./clip.mp4" /> // указали элементу атрибут ref => получили прямой доступ к DOM-элементу
      <button onClick={handleClick}>▶️</button> // привязали обработчик к кнопке 
    </>
  );
} 
```

**Для классовых компонентов** всё почти так же, только для создания рефа используется функция `React.createRef`, а сам реф обычно записывается в `this`:

Скопировать кодJSX

```
class VideoPlayer extends React.Component {
  constructor() {
    super();

    this.videoRef = React.createRef(); // создали реф и записали его в переменную — она будет свойством у this
  }

  handleClick = () => {
    this.videoRef.current.play(); // аналогично вызываем нужный метод на поле current объекта
  };

  render() {
    return (
      <>
        <video ref={this.videoRef} src="./clip.mp4" /> // всё так же, как у функциональных компонентов, но нужно добавить this
        <button onClick={this.handleClick}>▶️</button> // всё так же, как у функциональных компонентов, но нужно добавить this
      </>
    );
  }
} 
```

### Рефы как локальные переменные

У рефов есть дополнительное назначение в функциональных компонентах. Иногда нужно записать какие-то данные внутри компонента, но использовать стейт при этом не получается.

Предположим, мы хотим вести счётчик рендеров в функциональном компоненте. Если используем стейт с помощью хука `useState`, то каждый раз при его обновлении будет снова вызываться рендер и обновлять счётчик — получится замкнутый круг, и приложение зависнет.

В классовых компонентах для этого используют свойства экземпляра класса: просто сохраняют всё нужное в `this` и при необходимости считывают.

В функциональных компонентах вместо этого используют рефы. Вот как должен выглядеть этот пример:

Скопировать кодJSX

```
function MessageComposer() {
  const [value, setValue] = React.useState('');
  const counterRef = React.useRef(0);

  function handleChange(e) {
    setValue(e.target.value);
  }

  return (
    <>
      <input type="text" value={value} onChange={handleChange} />
      <h4>Рендеров: {++counterRef.current}</h4>
    </>
  );
} 
```

Здесь мы используем паттерн «управляемый инпут», который был описан в предыдущем уроке. У этого компонента происходит рендер каждый раз, когда пользователь меняет текст в поле ввода.

Старайтесь не злоупотреблять рефами и использовать их только в случае необходимости.