[[JavaScript]]

В предыдущем спринте вы разобрали понятие аутентификации — входа пользователя на сайт, — а затем написали её на стороне фронтенда. Теперь поработаем с процессами аутентификации и регистрации на стороне сервера. Регистрация с точки зрения сервера — создание нового пользователя в базе данных. В этом уроке мы расскажем, как это сделать.

## Добавление пользователя в базу данных

Сначала создадим, а затем запишем пользователя в базу данных.

### Создание

Создадим модель пользователя с двумя полями:

Скопировать кодJAVASCRIPT

```
// models/user.js

const mongoose = require('mongoose');

const userSchema = new mongoose.Schema({
  email: {
    type: String,
    required: true,
    unique: true
  },
  password: {
    type: String,
    required: true,
    minlength: 8
  }
});

module.exports = mongoose.model('user', userSchema); 
```

Email должен быть уникальным, поскольку пользователь проходит аутентификацию по электронной почте. Для этого мы добавляем свойство `unique` со значением `true`. Так в базе не окажется несколько пользователей с одинаковой почтой.

### Запись пользователя в БД

Настроим запись пользователя в базу данных при запросе к серверу. Для этого создадим контроллер `createUser`. Внутри него мы получим почту и пароль, которые пришли в запросе, и запишем их в базу:

Скопировать кодJAVASCRIPT

```
// controllers/users.js

const User = require('../models/user');

exports.createUser = (req, res) => User.create({
  email: req.body.email,
  password: req.body.password,
})
  .then((user) => res.send(user))
  .catch((err) => res.status(400).send(err)); 
```

Если пользователь с такой почтой уже есть в базе, сработает блок `catch` и записи не произойдёт.

## Хеширование пароля

Пароль в базе следует хранить в зашифрованном виде. Иначе пользователи окажутся в уязвимом положении: если у злоумышленника окажется доступ к базе данных, он получит доступ и к аккаунтам.

Пароли хранят в виде хеша. Из него невозможно получить пароль, поэтому злоумышленник не сможет добраться до аккаунтов пользователей даже если завладеет базой данных.

Для хеширования пароля понадобится модуль `bcryptjs`. Его нужно установить, как мы делали это с другими модулями, а затем импортировать в проект:

Скопировать кодJAVASCRIPT

```
// controllers/users.js

const bcrypt = require('bcryptjs'); // импортируем bcrypt
const User = require('../models/user'); 
```

Добавим код для хеширования в контроллер создания пользователя. За это отвечает метод `hash`:

Скопировать кодJAVASCRIPT

```
// controllers/users.js

const bcrypt = require('bcryptjs'); // импортируем bcrypt
const User = require('../models/user');

exports.createUser = (req, res) => {
  // хешируем пароль
  bcrypt.hash(req.body.password, 10)
    .then(hash => User.create({
      email: req.body.email,
      password: hash, // записываем хеш в базу
    }))
    .then((user) => res.send(user))
    .catch((err) => res.status(400).send(err));
}; 
```

Метод принимает на вход два параметра: пароль и длину так называемой «соли» — случайной строки, которую метод добавит к паролю перед хешированем.

### Зачем нужна «соль»? Таблица поиска

Хешировать пароль без прибавления «соли» небезопасно. Можно сгенерировать множество хешей и собрать их в таблицу, а затем украсть базу данных и попытаться найти соответствие между двумя хешами. Если такое совпадение найдётся, злоумышленник получит пароль пользователя.

![image](https://pictures.s3.yandex.net/resources/hash___1__19_1600444784.png)

«Соль» решает эту проблему. Прежде чем хешировать пароль, к нему добавятся случайные символы — это полностью поменяет итоговый хеш. Даже для двух одинаковых паролей получатся разные хеши. Тогда злоумышленнику нужно составить по отдельной таблице хешей для каждой соли. Это по сути прямой перебор.

![image](https://pictures.s3.yandex.net/resources/hash___1__20_1600444861.png)