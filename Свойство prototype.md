[[Продвинутый JavaScript]]

В прошлом уроке вы узнали о функциях-конструкторах. Такие функции вызывают с оператором `new`: он говорит движку, что перед тем как исполнять код функции, нужно создать объект, а после выполнения — созданный объект вернуть.

Но вернёмся к тому, как наша функция выглядела до превращения в конструктор. В её теле был такой шаг:

Скопировать кодJAVASCRIPT

```
const newSong = Object.create(songPrototype); 
```

Этим шагом мы говорили движку, что нужно создавать не просто пустой объект, а пустой объект с `songPrototype` в качестве прототипа. Но когда мы переделали функцию в конструктор, этот шаг потеряли. Так что теперь движок не знает, какой объект брать за прототип новых объектов, что приводит к ошибке:

Скопировать кодJAVASCRIPT

```
const songPrototype = {
  like: function () {
    this.isLiked = !this.isLiked;
  }
};

function Song(title, artist) {
  this.title = title;
  this.artist = artist;
  this.isLiked = false;
}

const song1 = new Song('Футбольный мяч', 'Антоха MC');

console.log(song1.like); // undefined — значит такого свойство нет ни в объекте, ни в прототипе

song1.like(); // ошибка — undefined не функция 
```

Выход из этой ситуации прост. Помните, что функция — это объект? Так вот, у любой функции-конструктора есть свойство `prototype`. То, что хранится в этом свойстве, становится прототипом объекта, созданного этой функцией.

То есть, когда функция `Song` будет вызвана с оператором `new`, за кулисами произойдёт следующее:

Скопировать кодJAVASCRIPT

```
function Song(title, artist) {
  // Произойдёт за кулисами:
    // this = Object.create(Song.prototype);

  this.title = title;
  this.artist = artist;
  this.isLiked = false;
}

const song1 = new Song('Футбольный мяч', 'Антоха MC'); 
```

Объект `Song.prototype` будет автоматически добавлен как прототип для нового объекта, то есть в его свойство `__proto__`.

Поэтому нужно записать в свойство `like` объекта `prototype` функцию из переменной `songPrototype` — тогда всё снова заработает.

Скопировать кодJAVASCRIPT

```
function Song(title, artist) {
  this.title = title;
  this.artist = artist;
  this.isLiked = false;
}

// добавим функцию like в объект Song.prototype
Song.prototype.like = function () {
  this.isLiked = !this.isLiked;
};

const song1 = new Song('Футбольный мяч', 'Антоха MC');

/* теперь функция like снова есть
в прототипе и доступна в новых объектах */

console.log(song1.isLiked); // false
song1.like();
console.log(song1.isLiked); // true 
```

Не путайте свойства `__proto__` и `prototype` — это не одно и то же. Вот в чём отличия:

-   свойство `__proto__` принадлежит объекту, свойство `prototype` — функции-конструктору;
-   эти два свойства служат разным целям. `__proto__` нужно движку для того, чтобы знать, где искать свойство, если в объекте оно не найдено. А свойство `prototype` — чтобы движок понял, куда будет вести ссылка `__proto__` у объекта, который создаёт функция-конструктор.

## Функции-конструкторы: резюме

Функции, конструирующие объекты, называют функциями-конструкторами.

Функции-конструкторы называют с заглавной буквы. Это подразумевает, что такую функцию нужно вызывать с оператором `new`.

Скопировать кодJAVASCRIPT

```
const song1 = new Song('Футбольный мяч', 'Антоха MC');
const song2 = new Song('На заре', 'Альянс');
const song3 = new Song('Ай', 'Хаски'); 
```

Вызов c `new` автоматически создаёт пустой объект, записывает его в `this`, и после того, как функция отработала, возвращает `this`. Мы же в своём коде модифицируем `this` в теле функции:

Скопировать кодJAVASCRIPT

```
function Song(title, artist) {
  this.title = title;
  this.artist = artist;
  this.isLiked = false;
} 
```

В свойство `prototype` функции-конструктора можно положить методы и свойства, которые будут добавлены в прототип, то есть в свойство `__proto__` сконструированного объекта:

Скопировать кодJAVASCRIPT

```
// like будет добавлен в прототип объектов песен
Song.prototype.like = function () {
  this.isLiked = !this.isLiked;
}; 
```