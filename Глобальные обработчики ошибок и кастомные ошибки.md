[[JavaScript]]

Иногда, несмотря на все наши старания, возникают ситуации, когда некоторые ошибки оказываются необработанными. В таких случаях код завершается ошибкой, а приложение падает. К счастью, в Node.js есть механизм, который позволяет отследить подобные ситуации — это глобальные обработчики ошибок.

### Глобальные обработчики ошибок

Чтобы добавить глобальный обработчик ошибок, необходимо подписаться на событие `uncaughtException` встроенного модуля `process`.

Для обработки ошибок вы можете реализовать собственную логику, однако в качестве примера мы ограничимся выводом информации о них в консоль.

Код, который реализует глобальный обработчик, выглядит так:

Скопировать кодJAVASCRIPT

```
const process = require('process');

process.on('uncaughtException', (err, origin) => {
   console.log(`${origin} ${err.name} c текстом ${err.message} не была обработана. Обратите внимание!`);
});

// Выбросим синхронную ошибку
throw new Error(`Ошибка, которую мы пропустили`); 
```

Этот обработчик перехватывает ошибки как в синхронных функциях, так и в промисах. В этом можно убедиться, если заменить выброс ошибки `throw ...` на `Promise.reject(...)`.

Определить, где произошла ошибка, можно с помощью значения параметра `origin` функции-обработчика. Если он равен `unhandledRejection`, то ошибка произошла в промисе, иначе — была выброшена при помощи `throw`.

Теперь ни одна ошибка, которая возникла в процессе работы сервиса, не останется без внимания.

### Описываем собственные ошибки. Кастомные ошибки в JS

Часто в процессе разработки нужно расширить объект ошибки и включить в него дополнительную информацию, необходимую для её обработки. Например, в ситуации, когда нам требуется задать собственное имя ошибки или указать статус-код ответа, с которым она возвратится пользователю.

Поскольку ошибка — обычный объект, это можно сделать «руками». Достаточно прописать информацию в качестве свойства конкретного экземпляра ошибки.

Но на практике разработчики обычно описывают кастомные классы ошибок, которые расширяют стандартный класс `Error`. Это позволяет избежать дублирования кода, если ошибка используется многократно.

Опишем вашу первую кастомную ошибку — ошибку валидации данных:

Скопировать кодJAVASCRIPT

```
class ValidationError extends Error {
  constructor(message) {
    super(message);
    this.name = "ValidationError";
    this.statusCode = 400;
  }
}
 
```

Всё, что мы здесь делаем — расширяем стандартную ошибку `Error`, задавая значения полей `name` и `statusCode` в конструкторе. В дальнейшем поле `name` потребуется нам при определении типа ошибки.

Воспользоваться собственной ошибкой можно также как и стандартной, например: `throw new ValidationError("Произошла ошибка валидации")`.

Разные проблемы требуют разных сценариев обработки, поэтому важно уметь отличать друг от друга ошибки разных типов. В следующем уроке поговорим том, как это сделать.