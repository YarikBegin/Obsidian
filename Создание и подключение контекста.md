[[React Router]]

Конечно, можно было бы использовать поднятие стейта: хранить выбранную настройку в стейте компонента `App` и добавить каждому компоненту пропс `translations`, который будет задаваться родителем и пробрасываться дальше всем дочерним элементам. Но такой подход потребует много дополнительного кода.

Чтобы не писать это вручную, разработчики «Реакта» предлагают использовать контекст — специальный способ передачи данных одновременно во все компоненты поддерева или даже всего приложения.

Чтобы создать контекст, нужно использовать встроенный метод `React.createContext`. Этот метод возвращает новый объект контекста. Важное свойство этого объекта — `Provider`. В нём содержится специальный «Реакт-компонент», который позволяет внедрить контекст в определённый участок существующего JSX-дерева.

Обычно контекст создаётся в отдельном файле и экспортируется из него. Иногда в этом файле находится и само содержимое вариантов контекста:

Скопировать кодJSX

```
// translationContext.js

export const TranslationContext = React.createContext();

export const translations = {
  en: {
    greeting: 'Hello World',
  },
  ru: {
    greeting: 'Привет, мир!',
  },
}; 
```

Компонент `Provider` имеет пропс `value` со значением, которое нужно распространить всем дочерним элементам.

Скопировать кодJSX

```
// App.js

// Импортируем объект контекста
import { TranslationContext, translations } from './translationContext';

function App() {
  // Стейт, отвечающий за текущий язык
  const [lang, setLang] = React.useState('en');

  return (
        // «Внедряем» данные из translations[lang] с помощью провайдера контекста
    <TranslationContext.Provider value={translations[lang]}>
            {/* Поддерево, в котором будет доступен контекст */}
      <Main />
    </TranslationContext.Provider>
  );
} 
```

Хоть провайдер и распространяет контекст автоматически по всему поддереву, дополнительно нужно подключить каждый из дочерних компонентов, в которых на самом деле будут использоваться эти данные.

Например, у нас могут быть компоненты, у которых вообще нет текстового содержимого, поэтому не нужно, чтобы они тоже перерисовывались, когда пользователь меняет язык в приложении.

Классовые и функциональные компоненты по-разному подключаются к контексту внутри поддерева. В следующем уроке вы научитесь это делать.