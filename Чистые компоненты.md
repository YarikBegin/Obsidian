[[React]]

Благодаря технологии Virtual DOM «тяжёлые операции» в реальном DOM сведены к минимуму. Но в виртуальном DOM, наоборот, зачастую производится избыток «лёгких операций», что может сказываться на производительности кода. Важно знать о внутреннем устройстве «Реакта», чтобы писать оптимальный код.

### Проблема оптимизации: цепная реакция рендеров

Как вы знаете из урока про [«Жизненный цикл классовых компонентов»](https://praktikum.yandex.ru/trainer/web/lesson/3c792d50-412d-49f6-9f03-318e0bfac201/task/37bff174-ce2a-4f40-9451-4e69e7a6fedb/), если в каком-то месте виртуального дерева произошли изменения и был вызван рендер соответствующего компонента, это вызывает цепную реакцию рендеров для всех его дочерних компонентов. Часто это бывает не обязательно и даже избыточно. Особенно, если в исходном компоненте, к примеру, всего лишь поменялся CSS-класс.

Рассмотрим тот же пример со списком чатов. Допустим, при наведении курсора вы хотите, чтобы отображалась панель действий с чатом: «Не беспокоить» и «Удалить». Конечно, лучше это сделать на чистом CSS, но это не всегда возможно.

Добавим внешний компонент `ChatWithTools`, который содержит `Chat` внутри себя и реагирует на события мыши, чтобы отображать дополнительные элементы.

Скопировать кодJSX

```
const ChatWithTools = (props) => {
  const [shouldShowTools, setShouldShowTools] = React.useState(false);

  function handleMouseEnter() {
    setShouldShowTools(true);
  }

  function handleMouseLeave() {
    setShouldShowTools(false);
  }

  return (
    <div className="chat-with-tools" onMouseEnter={handleMouseEnter} onMouseLeave={handleMouseLeave}>
      <Chat {...props} />

      {shouldShowTools && (
        <div className="tools">
          <button>Не беспокоить</button>
          <button>Удалить</button>
        </div>
      )}
    </div>
  );
};

const chats = /* ... */

ReactDOM.render((
  <>
    <h2>Чаты</h2>
    {chats.map((chat) => (
      <ChatWithTools id={chat.id} name={chat.name} lastMessageAt={chat.lastMessageAt} />
    ))}
  </>
), document.querySelector('#root')); 
```

Обратите внимание на «пробрасывание» пропсов: `<Chat {...props} />`. С помощью такой конструкции можно копировать в дочерний компонент сразу все собственные пропсы. Так в этом примере мы смогли разом пробросить все пропсы `ChatWithTools` в дочерний `Chat`.

В таком коде есть потенциальная проблема. Как мы говорили в одном из предыдущих уроков, отрисовка компонента всегда вызывается при отрисовке его родительского компонента. Убедиться в этом можно, добавив в структуру дочернего компонента генератор случайных чисел — при каждом вызове рендера случайное число будет меняться, и мы заметим это в пользовательском интерфейсе:

Скопировать кодJSX

```
const Chat = (props) => {
  return (
    <div className="chat">
      <img src={`img/${props.id}.png`} width="75" />
      <h2>{Math.random()}</h2>
      <div className="date">{props.lastMessageAt}</div>
    </div>
  );
}; 
```

Если бы не случайное число, никаких изменений бы не произошло, а рендер вызывался бы напрасно. С другой стороны, структура `Chat` могла быть сложнее и содержала бы в себе другие дочерние компоненты, которые в свою очередь содержали бы ещё компоненты. Для них рендер был бы вызван напрасно.

Чтобы этого не происходило, нужно использовать специальный тип компонентов, рендер которых происходит не при любом рендере их родителей, а только тогда, когда меняются их собственные пропсы. Такие компоненты называются «чистыми».

В классовом и функциональном подходе чистые компоненты создают по-разному.

### Создание чистого функционального компонента

Чтобы сделать функциональный компонент чистым, достаточно обернуть его в специальную функцию `React.memo`:

Скопировать кодJSX

```
const Chat = React.memo((props) => {
  return (
    <div className="chat">
      <img src={`img/${props.id}.png`} width="75" />
      <h2>{Math.random()}</h2>
      <div className="date">{props.lastMessageAt}</div>
    </div>
  );
}); 
```

Теперь при наведении мыши не происходит цепной реакции — она сразу «обрывается» на компоненте `Chat`, так как его пропсы не меняются:

Так мы используем ресурсы более разумно.

### Создание чистого классового компонента

Сделать чистым классовый компонент ещё проще: надо лишь наследоваться не от `React.Component`, а от `React.PureComponent`:

Скопировать кодJSX

```
class Chat extends React.PureComponent {
  render() {
    return (
      <div className="chat">
        <img src={`img/${this.props.id}.png`} width="75" />
        <h2>{Math.random()}</h2>
        <div className="date">{this.props.lastMessageAt}</div>
      </div>
    );
  };
} 
```

И `React.memo`, и `React.PureComponent` работают по схожему принципу: они запоминают последние переданные пропсы и последний результат рендера своего дочернего компонента. При следующей попытке рендера, если пропсы не изменились, они просто возвращают закэшированный результат. Если же пропсы изменились, вызывается рендер, после чего сохраняется новый кэш и последние пропсы.

Старайтесь всегда использовать чистые компоненты, кроме случаев, когда компоненты должны обновляться вместе со своими родителями.

### Поверхностное сравнение

`React.memo` и `React.PureComponent` определяют изменения в пропсах по алгоритму «поверхностного сравнения» (англ. shallow equal): предыдущее значение каждого пропса сравнивается с новым оператором `===`.

Поэтому нужно избегать ситуаций, когда значения пропсов со сложными типами создаются в момент передачи, например:

Скопировать кодJSX

```
<MyPureComponent
    userNames={['Gregory', 'James', 'Allison']}
    onClick={() => console.log(1)}
/> 
```

При каждом рендере значения этих пропсов по сути не меняются, но в действительности они создаются заново, значит, фильтр чистого компонента просто не сработает. Это происходит потому, что в JavaScript сложные типы данных не эквивалентны друг другу:

Скопировать кодJSX

```
['Gregory', 'James', 'Allison'] === ['Gregory', 'James', 'Allison'] // => false!
(() => console.log(1)) === (() => console.log(1)) // => false! 
```

Чистые компоненты, которым задаются пропсы таким образом, работать не будут. В будущем мы научимся избегать подобных ситуаций.